
SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


USE `qdm172705523_db`;

-- --------------------------------------------------------

--
-- 表的结构 `blog_administrator`
--

CREATE TABLE `blog_administrator` (
  `admin_id` int(11) NOT NULL,
  `admin_name` varchar(32) DEFAULT NULL,
  `admin_apwd` varchar(32) DEFAULT NULL,
  `admin_user_name` varchar(16) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- 转存表中的数据 `blog_administrator`
--

INSERT INTO `blog_administrator` VALUES
(1, 'Annani', '123456', 'Annani');

-- --------------------------------------------------------

--
-- 表的结构 `blog_article`
--

CREATE TABLE `blog_article` (
  `article_id` int(11) NOT NULL,
  `article_title` varchar(32) DEFAULT '无标题文章',
  `article_author` varchar(16) DEFAULT '宫关',
  `article_public_date` timestamp DEFAULT CURRENT_TIMESTAMP,
  `article_update_date` timestamp NOT NULL,
  `article_content` LONGTEXT,
  `article_text` LONGTEXT,
  `article_family` int(11) DEFAULT '1',
  `article_category` int(11) DEFAULT '1',
  `article_click_count` int(11) DEFAULT '0',
  `article_recommend` int(11) DEFAULT '1',
  `article_show` tinyint(1) DEFAULT '1',
  `article_isPublic` tinyint(1) DEFAULT '0'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- 转存表中的数据 `blog_article`
--

INSERT INTO `blog_article` VALUES
(1, 'BFC 神奇背后的原理', '前端精选文摘', '2017-11-08 12:30:40', '2017-11-06 09:07:30', '<p>&nbsp;&nbsp;&nbsp;&nbsp;BFC 已经是一个耳听熟闻的词语了，网上有许多关于 BFC 的文章，介绍了如何触发 BFC 以及 BFC 的一些用处（如清浮动，防止 margin 重叠等）。虽然我知道如何利用 BFC 解决这些问题，但当别人问我 BFC 是什么，我还是不能很有底气地解释清楚。于是这两天仔细阅读了CSS2.1 spec 和许多文章来全面地理解BFC。 &nbsp;</p><h3>一、BFC是什么？</h3><p>在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。</p><h4 id="box-css-">Box: CSS布局的基本单位</h4><p>Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：</p><ul><li>block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</li><li>inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；</li><li>run-in box: css3 中才有， 这儿先不讲了。</li></ul><h4>Formatting context</h4><p>Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。</p><p>CSS2.1 中只有&nbsp;<code>BFC&nbsp;</code>和&nbsp;<code>IFC</code>,&nbsp;<strong><a href="http://www.cnblogs.com/lhb25/category/146075.html" target="_blank">CSS3</a>&nbsp;</strong>中还增加了&nbsp;<code>GFC&nbsp;</code>和&nbsp;<code>FFC。</code></p><h4 id="bfc-">BFC 定义</h4><p>BFC(Block formatting context)直译为"块级格式化上下文"。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p><h4 id="bfc-">BFC布局规则：</h4><ul><li>内部的Box会在垂直方向，一个接一个地放置。&nbsp;</li><li>Box垂直方向的距离由margin决定。</li><li>属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。&nbsp;</li><li>BFC的区域不会与float box重叠。&nbsp;</li><li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。&nbsp;</li><li>计算BFC的高度时，浮动元素也参与计算<b> </b>​</li></ul><h3>二、哪些元素会生成BFC?</h3><ol><li>根元素</li><li>float属性不为none</li><li>position为absolute或fixed</li><li>display为inline-block, table-cell, table-caption, flex, inline-flex</li><li>overflow不为visible</li></ol><h3>三、BFC的作用及原理</h3><pre><code>&lt;style&gt;\n    body {\n        width: 300px;\n        position: relative;\n    }\n \n    .aside {\n        width: 100px;\n        height: 150px;\n        float: left;\n        background: #f66;\n    }\n \n    .main {\n        height: 200px;\n        background: #fcc;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class="aside"&gt;&lt;/div&gt;\n    &lt;div class="main"&gt;&lt;/div&gt;\n&lt;/body&gt;</code></pre><p>页面：<br>　　<img src="http://p1.qhimg.com/d/inn/4055c62a/4dca44a927d4c1ffc30e3ae5f53a0b79.png?_=3674372" style="max-width: 100%;"></p><p>根据<code>BFC</code>布局规则第3条：</p><blockquote><p>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</p></blockquote><p>因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触。</p><p>根据<code>BFC</code>布局规则第四条：</p><blockquote><p><code>BFC</code>的区域不会与<code>float box</code>重叠。</p></blockquote><p>我们可以通过通过触发main生成<code>BFC</code>， 来实现自适应两栏布局。</p><pre><code>.main {\n    overflow: hidden;\n}</code></pre><p>当触发main生成<code>BFC</code>后，这个新的<code>BFC</code>不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下：</p><p>&nbsp;<img src="http://p6.qhimg.com/t01077886a9706cb26b.png?_=3674372" style="max-width: 100%;">&nbsp;</p><h4 id="2-">2. 清除内部浮动</h4><p>代码：</p><pre><code>&lt;style&gt;\n    .par {\n        border: 5px solid #fcc;\n        width: 300px;\n    }\n \n    .child {\n        border: 5px solid #f66;\n        width:100px;\n        height: 100px;\n        float: left;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class="par"&gt;\n        &lt;div class="child"&gt;&lt;/div&gt;\n        &lt;div class="child"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;</code></pre><p>页面：<br>　　<img src="http://p1.qhimg.com/t016035b58195e7909a.png?_=3674372" style="max-width: 100%;"></p><p>根据<code>BFC</code>布局规则第六条：</p><blockquote><p>计算<code>BFC</code>的高度时，浮动元素也参与计算</p></blockquote><p>为达到清除内部浮动，我们可以触发par生成<code>BFC</code>，那么par在计算高度时，par内部的浮动元素child也会参与计算。</p><p>代码：</p><div><div id="highlighter_499159"><pre><code>.par {\n    overflow: hidden;\n}</code></pre></div></div><p>效果如下：<br>　　<img src="http://p2.qhimg.com/t016bbbe5236ef1ffd5.png?_=3674372" style="max-width: 100%;"></p><h4 id="3-margin-">3. 防止垂直 margin 重叠</h4><p>代码：</p><div><div id="highlighter_915432"><pre><code>&lt;style&gt;\n    p {\n        color: #f55;\n        background: #fcc;\n        width: 200px;\n        line-height: 100px;\n        text-align:center;\n        margin: 100px;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;p&gt;Haha&lt;/p&gt;\n    &lt;p&gt;Hehe&lt;/p&gt;\n&lt;/body&gt;</code></pre><p><br></p></div></div><p>页面：</p><p>&nbsp; &nbsp; &nbsp;&nbsp;<img src="http://p5.qhimg.com/t01b47b8b7d153c07cc.png?_=3674372" style="max-width:100%;"><br>两个p之间的距离为100px，发送了margin重叠。</p><p>根据BFC布局规则第二条：</p><blockquote><p><code>Box</code>垂直方向的距离由margin决定。属于同一个<code>BFC</code>的两个相邻<code>Box</code>的margin会发生重叠</p></blockquote><p>我们可以在p外面包裹一层容器，并触发该容器生成一个<code>BFC</code>。那么两个P便不属于同一个<code>BFC</code>，就不会发生margin重叠了。<br>代码：</p><div><div id="highlighter_84574"><pre><code>&lt;style&gt;\n    .wrap {\n        overflow: hidden;\n    }\n    p {\n        color: #f55;\n        background: #fcc;\n        width: 200px;\n        line-height: 100px;\n        text-align:center;\n        margin: 100px;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;p&gt;Haha&lt;/p&gt;\n    &lt;div class="wrap"&gt;\n        &lt;p&gt;Hehe&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/body&gt;</code></pre><p><br></p></div></div><p>效果如下:</p><p>&nbsp; &nbsp; &nbsp;<img src="http://p3.qhimg.com/t0118d1d2badbb00521.png?_=3674372" style="max-width:100%;"></p><p><br></p><p><br><span style="color: inherit; font-family: inherit; font-size: 24px;">总结</span></p><p>其实以上的几个例子都体现了<code>BFC</code>布局规则第五条：</p><blockquote><p><code>BFC</code>就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p></blockquote><p>因为<code>BFC</code>内部的元素和外部的元素绝对不会互相影响，因此， 当<code>BFC</code>外部存在浮动时，它不应该影响<code>BFC</code>内部Box的布局，<code>BFC</code>会通过变窄，而不与浮动有重叠。同样的，当<code>BFC</code>内部有浮动时，为了不影响外部元素的布局，<code>BFC</code>计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。</p><p><br></p><p>原文来自：&nbsp;<a href="http://blog.melonhuang.gitpress.org/~docs/css/1formattingContext.md" target="_blank" style="background-color: rgb(255, 255, 255);">前端文摘：BFC 神奇背后的原理</a><br></p>', '    BFC 已经是一个耳听熟闻的词语了，网上有许多关于 BFC 的文章，介绍了如何触发 BFC 以及 BFC 的一些用处（如清浮动，防止 margin 重叠等）。虽然我知道如何利用 BFC 解决这些问题，但当别人问我 BFC 是什么，我还是不能很有底气地解释清楚。于是这两天仔细阅读了CSS2.1 spec 和许多文章来全面地理解BFC。  一、BFC是什么？在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。Box: CSS布局的基本单位Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；run-in box: css3 中才有， 这儿先不讲了。Formatting contextFormatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。CSS2.1 中只有 BFC 和 IFC, CSS3 中还增加了 GFC 和 FFC。BFC 定义BFC(Block formatting context)直译为"块级格式化上下文"。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。BFC布局规则：内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 ​二、哪些元素会生成BFC?根元素float属性不为noneposition为absolute或fixeddisplay为inline-block, table-cell, table-caption, flex, inline-flexoverflow不为visible三、BFC的作用及原理&lt;style&gt;\n    body {\n        width: 300px;\n        position: relative;\n    }\n \n    .aside {\n        width: 100px;\n        height: 150px;\n        float: left;\n        background: #f66;\n    }\n \n    .main {\n        height: 200px;\n        background: #fcc;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class="aside"&gt;&lt;/div&gt;\n    &lt;div class="main"&gt;&lt;/div&gt;\n&lt;/body&gt;页面：　　根据BFC布局规则第3条：每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。因此，虽然存在浮动的元素aslide，但main的左边依然会与包含块的左边相接触。根据BFC布局规则第四条：BFC的区域不会与float box重叠。我们可以通过通过触发main生成BFC， 来实现自适应两栏布局。.main {\n    overflow: hidden;\n}当触发main生成BFC后，这个新的BFC不会与浮动的aside重叠。因此会根据包含块的宽度，和aside的宽度，自动变窄。效果如下：  2. 清除内部浮动代码：&lt;style&gt;\n    .par {\n        border: 5px solid #fcc;\n        width: 300px;\n    }\n \n    .child {\n        border: 5px solid #f66;\n        width:100px;\n        height: 100px;\n        float: left;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class="par"&gt;\n        &lt;div class="child"&gt;&lt;/div&gt;\n        &lt;div class="child"&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;页面：　　根据BFC布局规则第六条：计算BFC的高度时，浮动元素也参与计算为达到清除内部浮动，我们可以触发par生成BFC，那么par在计算高度时，par内部的浮动元素child也会参与计算。代码：.par {\n    overflow: hidden;\n}效果如下：　　3. 防止垂直 margin 重叠代码：&lt;style&gt;\n    p {\n        color: #f55;\n        background: #fcc;\n        width: 200px;\n        line-height: 100px;\n        text-align:center;\n        margin: 100px;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;p&gt;Haha&lt;/p&gt;\n    &lt;p&gt;Hehe&lt;/p&gt;\n&lt;/body&gt;页面：      两个p之间的距离为100px，发送了margin重叠。根据BFC布局规则第二条：Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠我们可以在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。代码：&lt;style&gt;\n    .wrap {\n        overflow: hidden;\n    }\n    p {\n        color: #f55;\n        background: #fcc;\n        width: 200px;\n        line-height: 100px;\n        text-align:center;\n        margin: 100px;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;p&gt;Haha&lt;/p&gt;\n    &lt;div class="wrap"&gt;\n        &lt;p&gt;Hehe&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/body&gt;效果如下:     总结其实以上的几个例子都体现了BFC布局规则第五条：BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。原文来自： 前端文摘：BFC 神奇背后的原理', 1, 0, 23, 7, 1, 1),
(19, '关于跨域,以及跨域的几种方式', '陈诗烁（博客园）', '2017-11-08 12:31:20', '2017-11-04 11:02:49', '<h1><a id="cb_post_title_url" href="http://www.cnblogs.com/chenshishuo/p/4919224.html">关于跨域,以及跨域的几种方式</a></h1><div></div><div><div id="cnblogs_post_body"><p>首先我们来想一想</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 为什么会有跨域这个名词的出现呢?</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 跨域又是什么呢?为何要跨域?</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 浏览器的同源策略又是什么?怎么解决?</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jsonp又是什么?</p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 跨域的原理又是什么呢?</p><p>名词解释:</p><p><strong>跨域:</strong></p><p>浏览器对于javascript的同源策略的限制,例如a.cn下面的js不能调用b.cn中的js,对象或数据(因为a.cn和b.cn是不同域),所以跨域就出现了.</p><p>上面提到的,同域的概念又是什么呢??? 简单的解释就是相同域名,端口相同,协议相同</p><p>&nbsp;</p><p><strong>同源策略:</strong></p><p>请求的url地址,必须与浏览器上的url地址处于同域上,也就是域名,端口,协议相同.</p><p>比如:我在本地上的域名是study.cn,请求另外一个域名一段数据,这个时候在浏览器上会报错:</p><p>这是同源策略的保护,如果浏览器对javascript没有同源策略的保护,那么一些重要的机密网站将会很危险~</p><table border="1" align="left"><tbody><tr><td colspan="3">study.cn/json/jsonp/jsonp.html</td></tr><tr><td>&nbsp;请求地址</td><td>&nbsp;形式</td><td>&nbsp;结果</td></tr><tr><td>&nbsp;http://study.cn/test/a.html</td><td>同一域名,不同文件夹</td><td>&nbsp;成功</td></tr><tr><td>&nbsp;http://study.cn/json/jsonp/jsonp.html</td><td>同一域名,统一文件夹</td><td>&nbsp;成功</td></tr><tr><td>&nbsp;http://a.study.cn/json/jsonp/jsonp.html</td><td>不同域名,文件路径相同</td><td>&nbsp;失败</td></tr><tr><td>&nbsp;http://study.cn:8080/json/jsonp/jsonp.html</td><td>&nbsp;同一域名,不同端口</td><td>&nbsp;失败</td></tr><tr><td>&nbsp;https://study.cn/json/jsonp/jsonp.html</td><td>&nbsp;同一域名,不同协议　　</td><td>&nbsp;失败</td></tr></tbody></table><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p><br></p><p><strong>jsonp:</strong></p><p><em>jsonp</em>&nbsp;<em>全称</em>是JSON with Padding,是为了解决跨域请求资源而产生的解决方案,是一种依靠开发人员创造出的一种非官方跨域数据交互协议。</p><p>一个是描述信息的格式，一个是信息传递双方约定的方法。</p><p><strong>jsonp的产生:</strong></p><p>1.AJAX直接请求普通文件存在跨域无权限访问的问题,不管是静态页面也好.<br></p><p>2.不过我们在调用js文件的时候又不受跨域影响,比如引入jquery框架的,或者是调用相片的时候</p><p>3.凡是拥有scr这个属性的标签都可以跨域例如&lt;script&gt;&lt;img&gt;&lt;iframe&gt;</p><p>4.如果想通过纯web端跨域访问数据只有一种可能,那就是把远程服务器上的数据装进js格式的文件里.<br></p><p>5.而json又是一个轻量级的数据格式,还被js原生支持</p><p>6.为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback&nbsp;参数给服务端，</p><p><font color="#46acc8">demo1:<strong>基于script标签实现跨域</strong></font></p><p>举个例子:我在http://study.cn/json/jsonp/jsonp_2.html下请求一个远程的js文件</p><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset="UTF-8"&gt;\n&lt;title&gt;Insert title here&lt;/title&gt;\n\n&lt;script type="text/javascript"&gt;\n    var message = function(data) {\n        alert(data[1].title);\n    };\n&lt;/script&gt;\n\n&lt;script type="text/javascript" src="http://web.cn/js/message.js"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=''testdiv''&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><p>远程的message.js文件是&nbsp;</p><pre><code>message([\n     {"id":"1", "title":"天津新闻联播，雷人搞笑的男主持人"},\n     {"id":"2", "title":"楼市告别富得流油 专家:房价下跌是大概率事件"},\n     {"id":"3", "title":"法国人关注时事 八成年轻人每天阅读新闻"},\n     {"id":"4", "title":"新闻中的历史,历史中的新闻"},\n     {"id":"5", "title":"东阳新闻20140222"},\n     {"id":"6", "title":"23个职能部门要增加新闻发布频次"},\n     {"id":"7", "title":"《贵州新闻联播》 中国美丽乡村"},\n     {"id":"8", "title":"朝韩离散家属团聚首轮活动结束"},\n     {"id":"9", "title":"索契冬奥会一天曝出两例兴奋剂事件"},\n     {"id":"10", "title":"今天中国多地仍将出现中度霾"}\n ]);</code></pre><p>这个时候我们得到的相应头是：</p><p><img src="http://images2015.cnblogs.com/blog/825922/201510/825922-20151029001049279-2032395919.png" style="max-width: 100%;"></p><p>&nbsp;<br></p><p>这样就实现跨域成功了,因为服务端返回数据时会将这个callback参数(message)作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。</p><p><font color="#46acc8">demo2:基于script标签实现跨域</font></p><p>让远程js知道它应该调用的本地函数叫什么名字,只要服务端提供的js脚本是动态生成的就好了,这样前台只需要传一个callback参数过去告诉服务端,我需要XXX代码,于是服务端就会得到相应了.<br></p><p>例如 在http://study.cn/json/jsonp/jsonp_3.html页面请求&nbsp;http://192.168.31.137/train/test/jsonpthree</p><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset="UTF-8"&gt;\n&lt;title&gt;Insert title here&lt;/title&gt;\n\n&lt;script type="text/javascript"&gt;\n    var messagetow = function(data){\n        alert(data);\n    };\n    var url = "http://192.168.31.137/train/test/jsonpthree?callback=messagetow";\n    var script = document.createElement(''script''); \n    script.setAttribute(''src'', url); \n    document.getElementsByTagName(''head'')[0].appendChild(script);\n&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><p>得到的响应头是:&nbsp;</p><p><img src="http://images2015.cnblogs.com/blog/825922/201510/825922-20151029003309607-494083121.png" style="max-width: 100%;" class="">&nbsp;<br></p><p><font color="#46acc8">demo3:&nbsp;&nbsp;<strong>基于jquery跨域</strong></font><br></p><p>那么如何用jquery来实现我们的跨域呢???jquery已经把跨域封装到ajax上了,而且封装得非常的好,使用起来也特别方便</p><p>如果是一般的ajax请求:</p><pre><code>$.ajax({\n        url:''http://192.168.31.137/train/test/testjsonp'',\n        type : ''get'',\n        dataType : ''text'',\n        success:function(data){\n            alert(data);\n        },\n        error:function(data){\n            alert(2);\n        }        \n    });</code></pre><p><br></p><p>那么在浏览器中会报错:&nbsp;</p><p><br></p><p><img src="http://images2015.cnblogs.com/blog/825922/201510/825922-20151029003601341-283881033.png" style="max-width: 100%;"></p><p><br></p><p>jsonp形式的ajax请求:并且通过get请求的方式传入参数,注意<font color="#f9963b">:跨域请求是只能是get请求不能使用post请求&nbsp;</font><br></p><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset="UTF-8"&gt;\n&lt;title&gt;Insert title here&lt;/title&gt;\n&lt;script type="text/javascript" src="./js/jquery.js"&gt;&lt;/script&gt;\n&lt;script type="text/javascript"&gt;\n$(document).ready(function(){\n    var name = ''chenshishuo'';\n    var sex = ''man'';\n    var address = ''shenzhen'';\n    var looks = ''handsome '';\n     $.ajax({\n         type : ''get'',\n         url:''http://192.168.31.137/train/test/testjsonp'',\n        data : {\n            name : name,\n            sex : sex,\n            address : address,\n            looks : looks,\n        },\n        cache :false,\n        jsonp: "callback",\n        jsonpCallback:"success",\n        dataType : ''jsonp'',\n        success:function(data){\n            alert(data);\n        },\n        error:function(data){\n            alert(''error'');\n        }        \n    });\n});\n&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;input id=''inputtest'' value=''546'' name=''inputtest''&gt;\n&lt;div id=''testdiv''&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><pre>jsonp 传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(默认为:callback)<br></pre><pre>jsonpCallback 自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名</pre><p>看看请求头和相应头吧</p><p>请求头:jquery会自动带入callback参数,当服务端获取到这个参数后,返回回来.(响应头)</p><p><img src="http://images2015.cnblogs.com/blog/825922/201510/825922-20151029004223466-686609124.png" style="max-width:100%;"><br></p><p><img src="http://images2015.cnblogs.com/blog/825922/201510/825922-20151029004645247-1965441012.png" style="max-width:100%;" class=""><br></p><p>现在是不是明白了跨域的基本原理,和基本的使用方法呢??</p><p>上面我们说到img中的src可以自动调用远程图片的(这个比较简单我在这里就不说了)</p><p>还有ifram请求:</p><p>基于iframe实现的跨域要求两个域具有aa.xx.com,bb.xx.com 这种特点，</p><p>也就是两个页面必须属于一个基础域（例如都是xxx.com)，使用同一协议和同一端口，这样在两个页面中同时添加document.domain，就可以实现父页面调用子页面的函数</p><p>要点就是 :<strong>通过修改document.domain来跨子域</strong></p><p><font color="#46acc8">demo4:&nbsp;<strong>通过iframe来跨子域</strong></font></p><p>http://a.study.cn/a.html 请求 http://b.study.cn/b.html</p><p>在a.html:</p><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset="UTF-8"&gt;\n&lt;title&gt;Insert title here&lt;/title&gt;\n        &lt;script type="text/javascript"&gt;\n            document.domain = ''study.cn'';\n            function test() {\n                alert(document.getElementById(''a'').contentWindow);\n            }\n        &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;iframe id=''a'' src=''http://b.study.cn/b.html'' onload=''test()''&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><p>&nbsp;在b.html:&nbsp;</p><pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset="UTF-8"&gt;\n&lt;title&gt;Insert title here&lt;/title&gt;\n\n&lt;script type="text/javascript"&gt;\ndocument.domain = ''study.cn'';\n&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    我是b.study.cn的body\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><p>&nbsp;运行效果截图:&nbsp;</p><p><img src="http://images2015.cnblogs.com/blog/825922/201510/825922-20151029011335544-1456383564.png" style="max-width: 100%;">&nbsp;</p><p>&nbsp;我们就可以通过js访问到iframe中的各种属性和对象了<br></p><p>如果你想在http://a.study.cn/a.html页面中通过ajax直接请求页面http://b.study.cn/b.html，即使你设置了相同的document.domain也还是不行的.</p><p>所以修改document.domain的方法只适用于不同子域的框架(父类与子类)间的交互。</p><p>如果想通过使用ajax的方法去与不同子域间的数据交互或者是js调用，只有两种方法,一种是使用jsonp的方法外，还有一种是使用iframe来做一个代理。</p><p>原理就是让这个 iframe载入一个与你想要通过ajax获取数据的目标页面处在相同的域的页面，所以这个iframe中的页面是可以正常使用ajax去获取你要的数据 的，</p><p>然后就是通过我们刚刚讲得修改document.domain的方法，让我们能通过js完全控制这个iframe，这样我们就可以让iframe去发 送ajax请求，然后收到的数据我们也可以获得了。</p><p>&nbsp;</p><p>上面的所有知识点,应该可以解决第一开始提出的问题了吧.</p></div></div>', '关于跨域,以及跨域的几种方式首先我们来想一想              为什么会有跨域这个名词的出现呢?              跨域又是什么呢?为何要跨域?              浏览器的同源策略又是什么?怎么解决?              jsonp又是什么?              跨域的原理又是什么呢?名词解释:跨域:浏览器对于javascript的同源策略的限制,例如a.cn下面的js不能调用b.cn中的js,对象或数据(因为a.cn和b.cn是不同域),所以跨域就出现了.上面提到的,同域的概念又是什么呢??? 简单的解释就是相同域名,端口相同,协议相同 同源策略:请求的url地址,必须与浏览器上的url地址处于同域上,也就是域名,端口,协议相同.比如:我在本地上的域名是study.cn,请求另外一个域名一段数据,这个时候在浏览器上会报错:这是同源策略的保护,如果浏览器对javascript没有同源策略的保护,那么一些重要的机密网站将会很危险~study.cn/json/jsonp/jsonp.html 请求地址 形式 结果 http://study.cn/test/a.html同一域名,不同文件夹 成功 http://study.cn/json/jsonp/jsonp.html同一域名,统一文件夹 成功 http://a.study.cn/json/jsonp/jsonp.html不同域名,文件路径相同 失败 http://study.cn:8080/json/jsonp/jsonp.html 同一域名,不同端口 失败 https://study.cn/json/jsonp/jsonp.html 同一域名,不同协议　　 失败       jsonp:jsonp 全称是JSON with Padding,是为了解决跨域请求资源而产生的解决方案,是一种依靠开发人员创造出的一种非官方跨域数据交互协议。一个是描述信息的格式，一个是信息传递双方约定的方法。jsonp的产生:1.AJAX直接请求普通文件存在跨域无权限访问的问题,不管是静态页面也好.2.不过我们在调用js文件的时候又不受跨域影响,比如引入jquery框架的,或者是调用相片的时候3.凡是拥有scr这个属性的标签都可以跨域例如&lt;script&gt;&lt;img&gt;&lt;iframe&gt;4.如果想通过纯web端跨域访问数据只有一种可能,那就是把远程服务器上的数据装进js格式的文件里.5.而json又是一个轻量级的数据格式,还被js原生支持6.为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback 参数给服务端，demo1:基于script标签实现跨域举个例子:我在http://study.cn/json/jsonp/jsonp_2.html下请求一个远程的js文件&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset="UTF-8"&gt;\n&lt;title&gt;Insert title here&lt;/title&gt;\n\n&lt;script type="text/javascript"&gt;\n    var message = function(data) {\n        alert(data[1].title);\n    };\n&lt;/script&gt;\n\n&lt;script type="text/javascript" src="http://web.cn/js/message.js"&gt;&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div id=''testdiv''&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;远程的message.js文件是 message([\n     {"id":"1", "title":"天津新闻联播，雷人搞笑的男主持人"},\n     {"id":"2", "title":"楼市告别富得流油 专家:房价下跌是大概率事件"},\n     {"id":"3", "title":"法国人关注时事 八成年轻人每天阅读新闻"},\n     {"id":"4", "title":"新闻中的历史,历史中的新闻"},\n     {"id":"5", "title":"东阳新闻20140222"},\n     {"id":"6", "title":"23个职能部门要增加新闻发布频次"},\n     {"id":"7", "title":"《贵州新闻联播》 中国美丽乡村"},\n     {"id":"8", "title":"朝韩离散家属团聚首轮活动结束"},\n     {"id":"9", "title":"索契冬奥会一天曝出两例兴奋剂事件"},\n     {"id":"10", "title":"今天中国多地仍将出现中度霾"}\n ]);这个时候我们得到的相应头是： 这样就实现跨域成功了,因为服务端返回数据时会将这个callback参数(message)作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。demo2:基于script标签实现跨域让远程js知道它应该调用的本地函数叫什么名字,只要服务端提供的js脚本是动态生成的就好了,这样前台只需要传一个callback参数过去告诉服务端,我需要XXX代码,于是服务端就会得到相应了.例如 在http://study.cn/json/jsonp/jsonp_3.html页面请求 http://192.168.31.137/train/test/jsonpthree&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset="UTF-8"&gt;\n&lt;title&gt;Insert title here&lt;/title&gt;\n\n&lt;script type="text/javascript"&gt;\n    var messagetow = function(data){\n        alert(data);\n    };\n    var url = "http://192.168.31.137/train/test/jsonpthree?callback=messagetow";\n    var script = document.createElement(''script''); \n    script.setAttribute(''src'', url); \n    document.getElementsByTagName(''head'')[0].appendChild(script);\n&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;/body&gt;\n&lt;/html&gt;得到的响应头是:  demo3:  基于jquery跨域那么如何用jquery来实现我们的跨域呢???jquery已经把跨域封装到ajax上了,而且封装得非常的好,使用起来也特别方便如果是一般的ajax请求:$.ajax({\n        url:''http://192.168.31.137/train/test/testjsonp'',\n        type : ''get'',\n        dataType : ''text'',\n        success:function(data){\n            alert(data);\n        },\n        error:function(data){\n            alert(2);\n        }        \n    });那么在浏览器中会报错: jsonp形式的ajax请求:并且通过get请求的方式传入参数,注意:跨域请求是只能是get请求不能使用post请求 &lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset="UTF-8"&gt;\n&lt;title&gt;Insert title here&lt;/title&gt;\n&lt;script type="text/javascript" src="./js/jquery.js"&gt;&lt;/script&gt;\n&lt;script type="text/javascript"&gt;\n$(document).ready(function(){\n    var name = ''chenshishuo'';\n    var sex = ''man'';\n    var address = ''shenzhen'';\n    var looks = ''handsome '';\n     $.ajax({\n         type : ''get'',\n         url:''http://192.168.31.137/train/test/testjsonp'',\n        data : {\n            name : name,\n            sex : sex,\n            address : address,\n            looks : looks,\n        },\n        cache :false,\n        jsonp: "callback",\n        jsonpCallback:"success",\n        dataType : ''jsonp'',\n        success:function(data){\n            alert(data);\n        },\n        error:function(data){\n            alert(''error'');\n        }        \n    });\n});\n&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;input id=''inputtest'' value=''546'' name=''inputtest''&gt;\n&lt;div id=''testdiv''&gt;&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;jsonp 传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(默认为:callback)jsonpCallback 自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名看看请求头和相应头吧请求头:jquery会自动带入callback参数,当服务端获取到这个参数后,返回回来.(响应头)现在是不是明白了跨域的基本原理,和基本的使用方法呢??上面我们说到img中的src可以自动调用远程图片的(这个比较简单我在这里就不说了)还有ifram请求:基于iframe实现的跨域要求两个域具有aa.xx.com,bb.xx.com 这种特点，也就是两个页面必须属于一个基础域（例如都是xxx.com)，使用同一协议和同一端口，这样在两个页面中同时添加document.domain，就可以实现父页面调用子页面的函数要点就是 :通过修改document.domain来跨子域demo4: 通过iframe来跨子域http://a.study.cn/a.html 请求 http://b.study.cn/b.html在a.html:&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset="UTF-8"&gt;\n&lt;title&gt;Insert title here&lt;/title&gt;\n        &lt;script type="text/javascript"&gt;\n            document.domain = ''study.cn'';\n            function test() {\n                alert(document.getElementById(''a'').contentWindow);\n            }\n        &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;iframe id=''a'' src=''http://b.study.cn/b.html'' onload=''test()''&gt;\n&lt;/body&gt;\n&lt;/html&gt; 在b.html: &lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset="UTF-8"&gt;\n&lt;title&gt;Insert title here&lt;/title&gt;\n\n&lt;script type="text/javascript"&gt;\ndocument.domain = ''study.cn'';\n&lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    我是b.study.cn的body\n&lt;/body&gt;\n&lt;/html&gt; 运行效果截图:   我们就可以通过js访问到iframe中的各种属性和对象了如果你想在http://a.study.cn/a.html页面中通过ajax直接请求页面http://b.study.cn/b.html，即使你设置了相同的document.domain也还是不行的.所以修改document.domain的方法只适用于不同子域的框架(父类与子类)间的交互。如果想通过使用ajax的方法去与不同子域间的数据交互或者是js调用，只有两种方法,一种是使用jsonp的方法外，还有一种是使用iframe来做一个代理。原理就是让这个 iframe载入一个与你想要通过ajax获取数据的目标页面处在相同的域的页面，所以这个iframe中的页面是可以正常使用ajax去获取你要的数据 的，然后就是通过我们刚刚讲得修改document.domain的方法，让我们能通过js完全控制这个iframe，这样我们就可以让iframe去发 送ajax请求，然后收到的数据我们也可以获得了。 上面的所有知识点,应该可以解决第一开始提出的问题了吧.', 1, 0, 17, 5, 1, 1),
(20, '浏览器加载网页的顺序', '李寒星（博客园）', '2017-11-08 12:31:18', '2017-11-04 14:22:29', '<p>浏览器加载和渲染html的顺序</p><p>&nbsp;</p><p>1. 用户输入网址（假设是个 HTML 页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回 HTML 文件；</p><p>2. 浏览器开始载入 HTML 代码，发现 &lt;head&gt; 标签内有一个 &lt;link&gt; 标签引用外部 CSS 文件；</p><p>3. 浏览器又发出 CSS 文件的请求，服务器返回这个 CSS 文件；</p><p>4. 浏览器继续载入 HTML 中 &lt;body&gt; 部分的代码，并且 CSS 文件已经拿到手了，可以开始渲染页面了；</p><p>5. 浏览器在代码中发现一个 &lt;img&gt; 标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；</p><p>6. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；</p><p>7. 浏览器发现了一个包含一行 JavaScript 代码的 &lt;script&gt; 标签，赶快运行它；</p><p>8. JavaScript 脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个 &lt;div&gt;（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码；</p><p>9. 终于等到了 &lt;/html&gt; 的到来，浏览器泪流满面……</p><p>10. 等等，还没完，用户点了一下界面中的“换肤”按钮，JavaScript 让浏览器换了一下 &lt;link&gt; 标签的 CSS 路径；</p><p>11. 浏览器召集了在座的各位 &lt;div&gt;&lt;span&gt;&lt;ul&gt;&lt;li&gt; 们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。&nbsp;浏览器每天就这么来来回回跑着，要知道不同的人写出来的 HTML 和 CSS 代码质量参差不齐，说不定哪天跑着跑着就挂掉了。好在这个世界还有这么一群人——页面重构工程师，平时挺不起眼，也就帮视觉设计师们切切图啊改改字，其实背地里还是干了不少实事的。</p><p>&nbsp;</p><p>各个步骤的加载渲染时间，可以通过各个浏览器的插件跟踪到，例如IE的 httpwatch、火狐的firebug等等。</p><p>&nbsp;</p><p><strong>二、如何加快HTML页面加载速度</strong></p><p>&nbsp;</p><p><strong>1. 页面减肥</strong></p><p>a. 页面的肥瘦是影响加载速度最重要的因素。</p><p>b. 删除不必要的空格、注释。</p><p>c. 将inline的script和css移到外部文件。</p><p>d. 可以使用HTML Tidy来给HTML减肥，还可以使用一些压缩工具来给JavaScript减肥。</p><p>&nbsp;</p><p><strong>2. 减少文件数量</strong></p><p>a. 减少页面上引用的文件数量可以减少HTTP连接数。</p><p>b. 许多JavaScript、CSS文件可以合并最好合并，人家财帮子都把自己的JavaScript. functions和Prototype.js合并到一个base.js文件里去了。</p><p>&nbsp;</p><p><strong>3. 减少域名查询</strong></p><p>a. DNS查询和解析域名也是消耗时间的，所以要减少对外部JavaScript、CSS、图片等资源的引用，不同域名的使用越少越好。</p><p>&nbsp;</p><p><strong>4. 缓存重用数据</strong></p><p>a. 对重复使用的数据进行缓存。</p><p>&nbsp;</p><p><strong>5. 优化页面元素加载顺序</strong></p><p>a. 首先加载页面最初显示的内容和与之相关的JavaScript和CSS，然后加载HTML相关的东西，像什么不是最初显示相关的图片、flash、视频等很肥的资源就最后加载。</p><p>&nbsp;</p><p><strong>6. 减少inline JavaScript的数量</strong></p><p>a. 浏览器parser会假设inline JavaScript会改变页面结构，所以使用inline JavaScript开销较大。</p><p>b. 不要使用document.write()这种输出内容的方法，使用现代W3C DOM方法来为现代浏览器处理页面内容。</p><p>&nbsp;</p><p><strong>7. 使用现代CSS和合法的标签</strong></p><p>a. 使用现代CSS来减少标签和图像，例如使用现代CSS+文字完全可以替代一些只有文字的图片。</p><p>b. 使用合法的标签避免浏览器解析HTML时做“error correction”等操作，还可以被HTML Tidy来给HTML减肥。</p><p>&nbsp;</p><p><strong>8. Chunk your content</strong></p><p>a. 不要使用嵌套table，而使用非嵌套table或者div。将基于大块嵌套的table的layout分解成多个小table，这样就不需要等到整个页面（或</p><p>大table）内容全部加载完才显示。</p><p>&nbsp;</p><p><strong>9. 指定图像和table的大小</strong></p><p>a. 如果浏览器可以立即决定图像或table的大小，那么它就可以马上显示页面而不要重新做一些布局安排的工作。</p><p>b. 这不仅加快了页面的显示，也预防了页面完成加载后布局的一些不当的改变。</p><p>c. image使用height和width。</p>', '浏览器加载和渲染html的顺序 1. 用户输入网址（假设是个 HTML 页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回 HTML 文件；2. 浏览器开始载入 HTML 代码，发现 &lt;head&gt; 标签内有一个 &lt;link&gt; 标签引用外部 CSS 文件；3. 浏览器又发出 CSS 文件的请求，服务器返回这个 CSS 文件；4. 浏览器继续载入 HTML 中 &lt;body&gt; 部分的代码，并且 CSS 文件已经拿到手了，可以开始渲染页面了；5. 浏览器在代码中发现一个 &lt;img&gt; 标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码；6. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；7. 浏览器发现了一个包含一行 JavaScript 代码的 &lt;script&gt; 标签，赶快运行它；8. JavaScript 脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个 &lt;div&gt;（style.display=”none”）。杯具啊，突然就少了这么一个元素，浏览器不得不重新渲染这部分代码；9. 终于等到了 &lt;/html&gt; 的到来，浏览器泪流满面……10. 等等，还没完，用户点了一下界面中的“换肤”按钮，JavaScript 让浏览器换了一下 &lt;link&gt; 标签的 CSS 路径；11. 浏览器召集了在座的各位 &lt;div&gt;&lt;span&gt;&lt;ul&gt;&lt;li&gt; 们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。 浏览器每天就这么来来回回跑着，要知道不同的人写出来的 HTML 和 CSS 代码质量参差不齐，说不定哪天跑着跑着就挂掉了。好在这个世界还有这么一群人——页面重构工程师，平时挺不起眼，也就帮视觉设计师们切切图啊改改字，其实背地里还是干了不少实事的。 各个步骤的加载渲染时间，可以通过各个浏览器的插件跟踪到，例如IE的 httpwatch、火狐的firebug等等。 二、如何加快HTML页面加载速度 1. 页面减肥a. 页面的肥瘦是影响加载速度最重要的因素。b. 删除不必要的空格、注释。c. 将inline的script和css移到外部文件。d. 可以使用HTML Tidy来给HTML减肥，还可以使用一些压缩工具来给JavaScript减肥。 2. 减少文件数量a. 减少页面上引用的文件数量可以减少HTTP连接数。b. 许多JavaScript、CSS文件可以合并最好合并，人家财帮子都把自己的JavaScript. functions和Prototype.js合并到一个base.js文件里去了。 3. 减少域名查询a. DNS查询和解析域名也是消耗时间的，所以要减少对外部JavaScript、CSS、图片等资源的引用，不同域名的使用越少越好。 4. 缓存重用数据a. 对重复使用的数据进行缓存。 5. 优化页面元素加载顺序a. 首先加载页面最初显示的内容和与之相关的JavaScript和CSS，然后加载HTML相关的东西，像什么不是最初显示相关的图片、flash、视频等很肥的资源就最后加载。 6. 减少inline JavaScript的数量a. 浏览器parser会假设inline JavaScript会改变页面结构，所以使用inline JavaScript开销较大。b. 不要使用document.write()这种输出内容的方法，使用现代W3C DOM方法来为现代浏览器处理页面内容。 7. 使用现代CSS和合法的标签a. 使用现代CSS来减少标签和图像，例如使用现代CSS+文字完全可以替代一些只有文字的图片。b. 使用合法的标签避免浏览器解析HTML时做“error correction”等操作，还可以被HTML Tidy来给HTML减肥。 8. Chunk your contenta. 不要使用嵌套table，而使用非嵌套table或者div。将基于大块嵌套的table的layout分解成多个小table，这样就不需要等到整个页面（或大table）内容全部加载完才显示。 9. 指定图像和table的大小a. 如果浏览器可以立即决定图像或table的大小，那么它就可以马上显示页面而不要重新做一些布局安排的工作。b. 这不仅加快了页面的显示，也预防了页面完成加载后布局的一些不当的改变。c. image使用height和width。', 1, 0, 121, 5, 1, 1);
INSERT INTO `blog_article` VALUES
(21, '【原】雅虎前端优化的35条军规', '雅虎', '2017-11-08 12:35:53', '2017-11-04 14:24:12', '<div id="navCategory"><p><b>阅读目录</b></p><ul><li><a href="#articleHeader3" target="_blank">内容部分</a><br></li><li><a href="#articleHeader3" target="_blank">css部分</a><br></li><li><a href="#articleHeader14" target="_blank">js部分</a><br></li><li><a href="#articleHeader10" target="_blank">javascript, css</a><br></li><li><a href="#articleHeader31" target="_blank">图片</a><br></li><li><a href="#articleHeader25" target="_blank">cookie</a><br></li><li><a href="#articleHeader35" target="_blank">移动端</a><br></li><li><a href="#articleHeader6" target="_blank">服务器</a><br></li></ul></div><div><strong>摘要：</strong>无论是在工作中，还是在面试中，web前端性能的优化都是很重要的，那么我们进行优化需要从哪些方面入手呢？可以遵循雅虎的前端优化34条军规，不过现在已经是35条了，所以可以说是雅虎前端优化的35条军规。已分类，挺好的，这样对于优化有一个比较清晰的方向</div><div>&nbsp;</div><h2>&nbsp;内容部分</h2><h3 id="articleHeader3">尽量减少HTTP请求数</h3><p>　　80%的终端用户响应时间都花在了前端上，其中大部分时间都在下载页面上的各种组件：图片，样式表，脚本，Flash等等。减少组件数必然能够减少页面提交的HTTP请求数。这是让页面更快的关键。</p><p>　　减少页面组件数的一种方式是简化页面设计。但有没有一种方法可以在构建复杂的页面同时加快响应时间呢？嗯，确实有鱼和熊掌兼得的办法。</p><p><strong>　　合并文件</strong>是通过把所有脚本放在一个文件中的方式来减少请求数的，当然，也可以合并所有的CSS。如果各个页面的脚本和样式不一样的话，合并文件就是一项比较麻烦的工作了，但把这个作为站点发布过程的一部分确实可以提高响应时间。</p><p><strong>　　CSS Sprites</strong>是减少图片请求数量的首选方式。把背景图片都整合到一张图片中，然后用CSS的<code>background-image</code>和<code>background-position</code>属性来定位要显示的部分。</p><p><strong>　　图像映射</strong>可以把多张图片合并成单张图片，总大小是一样的，但减少了请求数并加速了页面加载。图片映射只有在图像在页面中连续的时候才有用，比如导航条。给image map设置坐标的过程既无聊又容易出错，用image map来做导航也不容易，所以不推荐用这种方式。</p><p><strong>　　行内图片（Base64编码）</strong>用<a href="http://tools.ietf.org/html/rfc2397" data-rapid_p="3"><code>data:</code>&nbsp;URL模式</a>来把图片嵌入页面。这样会增加HTML文件的大小，把行内图片放在（缓存的）样式表中是个好办法，而且成功避免了页面变“重”。但目前主流浏览器并不能很好地支持行内图片。</p><p>　　减少页面的HTTP请求数是个起点，这是提升站点首次访问速度的重要指导原则。</p><p>&nbsp;</p><h3 id="articleHeader11">2.减少DNS查找</h3><p>　　域名系统建立了主机名和IP地址间的映射，就像电话簿上人名和号码的映射一样。当你在浏览器输入www.yahoo.com的时候，浏览器就会联系DNS解析器返回服务器的IP地址。DNS是有成本的，它需要20到120毫秒去查找给定主机名的IP地址。在DNS查找完成之前，浏览器无法从主机名下载任何东西。</p><p>　　DNS查找被缓存起来更高效，由用户的ISP（网络服务提供商）或者本地网络存在一个特殊的缓存服务器上，但还可以缓存在个人用户的计算机上。DNS信息被保存在操作系统的DNS cache(微软Windows上的”DNS客户端服务”)里。大多数浏览器有独立于操作系统的自己的cache。只要浏览器在自己的cache里还保留着这条记录，它就不会向操作系统查询DNS。</p><p>　　IE默认缓存DNS查找30分钟，写在<code>DnsCacheTimeout</code>注册表设置中。Firefox缓存1分钟，可以用<code>network.dnsCacheExpiration</code>配置项设置。(Fasterfox把缓存时间改成了1小时 P.S. Fasterfox是FF的一个提速插件)</p><p>　　如果客户端的DNS cache是空的（包括浏览器的和操作系统的），DNS查找数等于页面上不同的主机名数，包括页面URL，图片，脚本文件，样式表，Flash对象等等组件中的主机名，减少不同的主机名就可以减少DNS查找。</p><p>　　减少不同主机名的数量同时也减少了页面能够并行下载的组件数量，避免DNS查找削减了响应时间，而减少并行下载数量却增加了响应时间。我的原则是把组件分散在2到4个主机名下，这是同时减少DNS查找和允许高并发下载的折中方案。</p><p>&nbsp;</p><h3 id="articleHeader13">3.避免重定向</h3><p>重定向用301和302状态码，下面是一个有301状态码的HTTP头：</p><div><pre>HTTP/1.1 301 Moved Permanently\n      Location: http://example.com/newuri\n      Content-Type: text/html</pre></div><p>　　浏览器会自动跳转到<code>Location</code>域指明的URL。重定向需要的所有信息都在HTTP头部，而响应体一般是空的。其实额外的HTTP头，比如<code>Expires</code>和<code>Cache-Control</code>也表示重定向。除此之外还有别的跳转方式：refresh元标签和JavaScript，但如果你必须得做重定向，最好用标准的3xxHTTP状态码，主要是为了让返回按钮能正常使用。</p><p>　　牢记重定向会拖慢用户体验，在用户和HTML文档之间插入重定向会延迟页面上的所有东西，页面无法渲染，组件也无法开始下载，直到HTML文档被送达浏览器。</p><p>　　有一种常见的极其浪费资源的重定向，而且web开发人员一般都意识不到这一点，就是URL尾部缺少一个斜线的时候。例如，跳转到<a href="http://astrology.yahoo.com/astrology" data-rapid_p="41">http://astrology.yahoo.com/astrology</a>会返回一个重定向到<a href="http://astrology.yahoo.com/astrology/" data-rapid_p="42">http://astrology.yahoo.com/astrology/</a>的301响应（注意添在尾部的斜线）。在Apache中可以用<code>Alias</code>，<code>mod_rewrite</code>或者<code>DirectorySlash</code>指令来取消不必要的重定向。</p><p>　　重定向最常见的用途是把旧站点连接到新的站点，还可以连接同一站点的不同部分，针对用户的不同情况（浏览器类型，用户帐号类型等等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用<code>Alias</code>和<code>mod_rewrite</code>，前提是两个代码路径都在相同的服务器上。如果是因为域名变化而使用了重定向，就可以创建一条CNAME（创建一个指向另一个域名的DNS记录作为别名）结合<code>Alias</code>或者<code>mod_rewrite</code>指令。</p><p>&nbsp;</p><h3 id="articleHeader16">4.让Ajax可缓存</h3><p>　　Ajax的一个好处是可以给用户提供即时反馈，因为它能够从后台服务器异步请求信息。然而，用了Ajax就无法保证用户在等待异步JavaScript和XML响应返回期间不会非常无聊。在很多应用程序中，用户能够一直等待取决于如何使用Ajax。例如，在基于web的电子邮件客户端中，用户为了寻找符合他们搜索标准的邮件消息，将会保持对Ajax请求返回结果的关注。重要的是，要记得“异步”并不意味着“即时”。</p><p>　　要提高性能，优化这些Ajax响应至关重要。最重要的提高Ajax性能的方法就是让响应变得可缓存，就像在<a href="https://developer.yahoo.com/performance/rules.html#expires" data-rapid_p="50">添上Expires或者Cache-Control HTTP头</a>中讨论的一样。下面适用于Ajax的其它规则：</p><ul><li><a href="https://developer.yahoo.com/performance/rules.html#gzip" data-rapid_p="51">Gzip组件</a></li><li><a href="https://developer.yahoo.com/performance/rules.html#dns_lookups" data-rapid_p="52">减少DNS查找</a></li><li><a href="https://developer.yahoo.com/performance/rules.html#minify" data-rapid_p="53">压缩JavaScript</a></li><li><a href="https://developer.yahoo.com/performance/rules.html#redirects" data-rapid_p="54">避免重定向</a></li><li><a href="https://developer.yahoo.com/performance/rules.html#etags" data-rapid_p="55">配置ETags</a></li></ul><p>　　我们一起看看例子，一个Web 2.0的电子邮件客户端用了Ajax来下载用户的通讯录，以便实现自动完成功能。如果用户从上一次使用之后再没有修改过她的通讯录，而且Ajax响应是可缓存的，有尚未过期的Expires或者Cache-Control HTTP头，那么之前的通讯录就可以从缓存中读出。必须通知浏览器，应该继续使用之前缓存的通讯录响应，还是去请求一个新的。可以通过给通讯录的Ajax URL里添加一个表明用户通讯录最后修改时间的时间戳来实现，例如<code>&amp;t=1190241612</code>。如果通讯录从上一次下载之后再没有被修改过，时间戳不变，通讯录就将从浏览器缓存中直接读出，从而避免一次额外的HTTP往返消耗。如果用户已经修改了通讯录，时间戳也可以确保新的URL不会匹配缓存的响应，浏览器将请求新的通讯录条目。</p><p>　　即使Ajax响应是动态创建的，而且可能只适用于单用户，它们也可以被缓存，而这样会让你的Web 2.0应用更快。</p><p>&nbsp;</p><h3 id="articleHeader19">5.延迟加载组件</h3><p>　　可以凑近看看页面并问自己：什么才是一开始渲染页面所必须的？其余内容都可以等会儿。</p><p>　　JavaScript是分隔onload事件之前和之后的一个理想选择。例如，如果有JavaScript代码和支持拖放以及动画的库，这些都可以先等会儿，因为拖放元素是在页面最初渲染之后的。其它可以延迟加载的部分包括隐藏内容（在某个交互动作之后才出现的内容）和折叠的图片。</p><p>　　工具可帮你减轻工作量：<a href="https://developer.yahoo.com/yui/imageloader/" data-rapid_p="64">YUI Image Loader</a>可以延迟加载折叠的图片，还有<a href="https://developer.yahoo.com/yui/get/" data-rapid_p="65">YUI Get utility</a>是一种引入JS和CSS的简单方法。<a href="http://www.yahoo.com/" data-rapid_p="66">Yahoo!主页</a>就是一个例子，可以打开Firebug的网络面板仔细看看。</p><p>　　最好让性能目标符合其它web开发最佳实践，比如“渐进增强”。如果客户端支持JavaScript，可以提高用户体验，但必须确保页面在不支持JavaScript时也能正常工作。所以，在确定页面运行正常之后，可以用一些延迟加载脚本增强它，以支持一些拖放和动画之类的华丽效果。</p><h3>&nbsp;</h3><h3 id="articleHeader20">6.预加载组件</h3><p>　　预加载可能看起来和延迟加载是相反的，但它其实有不同的目标。通过预加载组件可以充分利用浏览器空闲的时间来请求将来会用到的组件（图片，样式和脚本）。用户访问下一页的时候，大部分组件都已经在缓存里了，所以在用户看来页面会加载得更快。</p><p>实际应用中有以下几种预加载的类型：</p><ul><li>无条件预加载——尽快开始加载，获取一些额外的组件。google.com就是一个sprite图片预加载的好例子，这个sprite图片并不是google.com主页需要的，而是搜索结果页面上的内容。</li><li>条件性预加载——根据用户操作猜测用户将要跳转到哪里并据此预加载。在<a href="http://search.yahoo.com/" data-rapid_p="68">search.yahoo.com</a>的输入框里键入内容后，可以看到那些额外组件是怎样请求加载的。</li><li>提前预加载——在推出新设计之前预加载。经常在重新设计之后会听到：“这个新网站不错，但比以前更慢了”，一部分原因是用户访问先前的页面都是有旧缓存的，但新的却是一种空缓存状态下的体验。可以通过在将要推出新设计之前预加载一些组件来减轻这种负面影响，老站可以利用浏览器空闲的时间来请求那些新站需要的图片和脚本。</li></ul><h3>&nbsp;</h3><h3 id="articleHeader21">7.减少DOM元素的数量</h3><p>　　一个复杂的页面意味着要下载更多的字节，而且用JavaScript访问DOM也会更慢。举个例子，想要添加一个事件处理器的时候，循环遍历页面上的500个DOM元素和5000个DOM元素是有区别的。</p><p>　　大量的DOM元素是一种征兆——页面上有些内容无关的标记需要清理。正在用嵌套表格来布局吗？还是为了修复布局问题而添了一堆的<code>&lt;div&gt;</code>s？或许应该用更好的语义化标记。</p><p><a href="https://developer.yahoo.com/yui/" data-rapid_p="70">YUI CSS utilities</a>对布局有很大帮助：grids.css针对整体布局，fonts.css和reset.css可以用来去除浏览器的默认格式。这是个开始清理和思考标记的好机会，例如只在语义上有意义的时候使用<code>&lt;div&gt;</code>，而不是因为它能够渲染一个新行。</p><p>　　DOM元素的数量很容易测试，只需要在Firebug的控制台里输入：<code><br></code></p><div><pre>document.getElementsByTagName(''*'').length</pre></div><p>&nbsp;</p><p>　　那么多少DOM元素才算是太多呢？可以参考其它类似的标记良好的页面，例如<a href="http://www.yahoo.com/" data-rapid_p="71">Yahoo!主页</a>是一个相当繁忙的页面，但只有不到700个元素（HTML标签）。</p><h3>&nbsp;</h3><h3 id="articleHeader22">8.跨域分离组件</h3><p>　　分离组件可以最大化并行下载，但要确保只用不超过2-4个域，因为存在DNS查找的代价。例如，可以把HTML和动态内容部署在<code>www.example.org</code>，而把静态组件分离到<code>static1.example.org</code>和<code>static2.example.org</code>。</p><p>&nbsp;</p><h3 id="articleHeader23">9.尽量少用iframe</h3><p>　　用iframe可以把一个HTML文档插入到父文档里，重要的是明白iframe是如何工作的并高效地使用它。</p><p><code>&lt;iframe&gt;</code>的优点：</p><ul><li>引入缓慢的第三方内容，比如标志和广告</li><li>安全沙箱</li><li>并行下载脚本</li></ul><p><code>&lt;iframe&gt;</code>的缺点：</p><ul><li>代价高昂，即使是空白的iframe</li><li>阻塞页面加载</li><li>非语义</li></ul><h3>&nbsp;</h3><h3 id="articleHeader24">10.杜绝404</h3><p>　　HTTP请求代价高昂，完全没有必要用一个HTTP请求去获取一个无用的响应（比如404 Not Found），只会拖慢用户体验而没有任何好处。</p><p>　　有些站点用的是有帮助的404——“你的意思是xxx？”，这样做有利于用户体验，，但也浪费了服务器资源（比如数据库等等）。最糟糕的是链接到的外部JavaScript有错误而且结果是404。首先，这种下载将阻塞并行下载。其次，浏览器会试图解析404响应体，因为它是JavaScript代码，需要找出其中可用的部分。</p><p>&nbsp;</p><h2>css部分</h2><p>&nbsp;</p><h3 id="articleHeader9">11.避免使用CSS表达式</h3><p>&nbsp;</p><p>用CSS表达式动态设置CSS属性，是一种强大又危险的方式。从IE5开始支持，但从IE8起就不推荐使用了。例如，可以用CSS表达式把背景颜色设置成按小时交替的：</p><div><div><div id="highlighter_543326"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td><div>1</div></td><td><div><div><code>background-color</code><code>: expression( (new Date()).getHours()%</code><code>2</code>&nbsp;<code>?&nbsp;</code><code>"#B8D4FF"</code>&nbsp;<code>:&nbsp;</code><code>"#F08A00"</code>&nbsp;<code>);</code></div></div></td></tr></tbody></table></div></div></div><p>&nbsp;</p><h3 id="articleHeader29">12.选择&lt;link&gt;舍弃@import</h3><p>　　前面提到了一个最佳实践：为了实现逐步渲染，CSS应该放在顶部。</p><p>&nbsp; 在IE中用<code>@import</code>与在底部用<code>&lt;link&gt;</code>效果一样，所以最好不要用它。</p><p>&nbsp;</p><h3 id="articleHeader30">13.避免使用滤镜</h3><p>　　IE专有的<code>AlphaImageLoader</code>滤镜可以用来修复IE7之前的版本中半透明PNG图片的问题。在图片加载过程中，这个滤镜会阻塞渲染，卡住浏览器，还会增加内存消耗而且是被应用到每个元素的，而不是每个图片，所以会存在一大堆问题。</p><p>最好的方法是干脆不要用<code>AlphaImageLoader</code>，而优雅地降级到用在IE中支持性很好的PNG8图片来代替。如果非要用<code>AlphaImageLoader</code>，应该用下划线hack：<code>_filter</code>来避免影响IE7及更高版本的用户。</p><p>&nbsp;</p><h3 id="articleHeader7">14.把样式表放在顶部</h3><p>　　在Yahoo!研究性能的时候，我们发现把样式表放到文档的HEAD部分能让页面看起来加载地更快。这是因为把样式表放在head里能让页面逐步渲染。</p><p>　　关注性能的前端工程师想让页面逐步渲染。也就是说，我们想让浏览器尽快显示已有内容，这在页面上有一大堆内容或者用户网速很慢时显得尤为重要。给用户显示反馈（比如进度指标）的重要性已经被广泛研究过，并且被<a href="http://www.useit.com/papers/responsetime.html" data-rapid_p="21">记录</a>下来了。在我们的例子中，HTML页面就是进度指标！当浏览器逐渐加载页面头部，导航条，顶部logo等等内容的时候，这些都被正在等待页面加载的用户当作反馈，能够提高整体用户体验。</p><p>&nbsp;</p><p><br></p><h2>js部分</h2><p>&nbsp;</p><h3 id="articleHeader14">15.去除重复脚本</h3><p>　　页面含有重复的脚本文件会影响性能，这可能和你想象的不一样。在对美国前10大web站点的评审中，发现只有2个站点含有重复脚本。两个主要原因增加了在单一页面中出现重复脚本的几率：团队大小和脚本数量。在这种情况下，重复脚本会创建不必要的HTTP请求，执行无用的JavaScript代码，而影响页面性能。</p><p>　　IE会产生不必要的HTTP请求，而Firefox不会。在IE中，如果一个不可缓存的外部脚本被页面引入了两次，它会在页面加载时产生两个HTTP请求。即使脚本是可缓存的，在用户重新加载页面时也会产生额外的HTTP请求。</p><p>　　除了产生没有意义的HTTP请求之外，多次对脚本求值也会浪费时间。因为无论脚本是否可缓存，在Firefox和IE中都会执行冗余的JavaScript代码。</p><p>　　避免不小心把相同脚本引入两次的一种方法就是在模版系统中实现脚本管理模块。典型的脚本引入方法就是在HTML页面中用SCRIPT标签：</p><pre><code>&lt;script type="text/javascript" src="menu_1.0.17.js"&gt;&lt;/script&gt;</code></pre><p><br></p><h3 id="articleHeader27">16.尽量减少DOM访问</h3><p>用JavaScript访问DOM元素是很慢的，所以，为了让页面反应更迅速，应该：</p><ul><li>缓存已访问过的元素的索引</li><li>先“离线”更新节点，再把它们添到DOM树上</li><li>避免用JavaScript修复布局问题</li></ul><p>&nbsp;</p><h3 id="articleHeader28">17.用智能的事件处理器</h3><p>　　有时候感觉页面反映不够灵敏，是因为有太多频繁执行的事件处理器被添加到了DOM树的不同元素上，这就是推荐使用事件委托的原因。如果一个<code>div</code>里面有10个按钮，应该只给div容器添加一个事件处理器，而不是给每个按钮都添加一个。事件能够冒泡，所以可以捕获事件并得知哪个按钮是事件源。</p><p>&nbsp;</p><h3 id="articleHeader8">18.把脚本放在底部</h3><p>　　脚本会阻塞并行下载，HTTP/1.1官方文档建议浏览器每个主机名下并行下载的组件数不要超过两个，如果图片来自多个主机名，并行下载的数量就可以超过两个。如果脚本正在下载，浏览器就不开始任何其它下载任务，即使是在不同主机名下的。</p><p>　　有时候，并不容易把脚本移动到底部。举个例子，如果脚本是用<code>document.write</code>插入到页面内容中的，就没办法再往下移了。还可能存在作用域问题，在多数情况下，这些问题都是可以解决的。</p><p>　　一个常见的建议是用推迟（deferred）脚本，有<code>DEFER</code>属性的脚本意味着不能含有document.write，并且提示浏览器告诉他们可以继续渲染。不幸的是，Firefox不支持<code>DEFER</code>属性。在IE中，脚本可能被推迟，但不尽如人意。如果脚本可以推迟，我们就可以把它放到页面底部，页面就可以更快地载入。</p><p><br></p><h2>javascript, css&nbsp;</h2><h3>&nbsp;</h3><h3 id="articleHeader10">19.把JavaScript和CSS放到外面</h3><p>　　很多性能原则都是关于如何管理外部组件的，然而，在这些顾虑出现之前你应该问一个更基础的问题：应该把JavaScript和CSS放到外部文件中还是直接写在页面里？</p><p>实际上，用外部文件可以让页面更快，因为JavaScript和CSS文件会被缓存在浏览器。HTML文档中的行内JavaScript和CSS在每次请求该HTML文档的时候都会重新下载。这样做减少了所需的HTTP请求数，但增加了HTML文档的大小。另一方面，如果JavaScript和CSS在外部文件中，并且已经被浏览器缓存起来了，那么我们就成功地把HTML文档变小了，而且还没有增加HTTP请求数。</p><p>　　</p><h3 id="articleHeader12">20.压缩JavaScript和CSS</h3><p>　　压缩具体来说就是从代码中去除不必要的字符以减少大小，从而提升加载速度。代码最小化就是去掉所有注释和不必要的空白字符（空格，换行和tab）。在JavaScript中这样做能够提高响应性能，因为要下载的文件变小了。两个最常用的JavaScript代码压缩工具是JSMin和YUI Compressor，YUI compressor还可以压缩CSS。</p><p>　　混淆是一种可选的源码优化措施，要比压缩更复杂，所以混淆过程也更容易产生bug。在对美国前十的网站调查中，压缩可以缩小21%，而混淆能缩小25%。虽然混淆的缩小程度更高，但比压缩风险更大。</p><p>　　除了压缩外部脚本和样式，行内的<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>块也可以压缩。即使启用了gzip模块，先进行压缩也能够缩小5%或者更多的大小。JavaScript和CSS的用处越来越多，所以压缩代码会有不错的效果。</p><p><br></p><h2>图片</h2><p>&nbsp;</p><h3 id="articleHeader31">21.优化图片</h3><ul><li>尝试把GIF格式转换成PNG格式，看看是否节省空间。在所有的PNG图片上运行pngcrush（或者其它PNG优化工具）</li></ul><h3>&nbsp;</h3><h3 id="articleHeader32">22.优化CSS Sprite</h3><ul><li>在Sprite图片中横向排列一般都比纵向排列的最终文件小</li><li>组合Sprite图片中的相似颜色可以保持低色数，最理想的是256色以下PNG8格式</li><li>“对移动端友好”，不要在Sprite图片中留下太大的空隙。虽然不会在很大程度上影响图片文件的大小，但这样做可以节省用户代理把图片解压成像素映射时消耗的内存。100×100的图片是1万个像素，而1000×1000的图片就是100万个像素了。</li></ul><h3>&nbsp;</h3><h3 id="articleHeader33">23.不要用HTML缩放图片</h3><p>　　不要因为在HTML中可以设置宽高而使用本不需要的大图。如果需要<code><br></code></p><div><div id="highlighter_198287"><pre><code>&lt;img width="100" height="100" src="mycat.jpg" alt="My Cat" /&gt;</code></pre></div></div><p>　　</p><p>那么图片本身（mycat.jpg）应该是100x100px的，而不是去缩小500x500px的图片。</p><p>&nbsp;</p><h3 id="articleHeader34">24.用小的可缓存的favicon.ico（P.S. 收藏夹图标）</h3><p>　　favicon.ico是放在服务器根目录的图片，它会带来一堆麻烦，因为即便你不管它，浏览器也会自动请求它，所以最好不要给一个<code>404 Not Found</code>响应。而且只要在同一个服务器上，每次请求它时都会发送cookie，此外这个图片还会干扰下载顺序，例如在IE中，当你在onload中请求额外组件时，将会先下载favicon。</p><p>所以为了缓解favicon.ico的缺点，应该确保：</p><ul><li>足够小，最好在1K以下</li><li>设置合适的有效期HTTP头（以后如果想换的话就不能重命名了），把有效期设置为几个月后一般比较安全，可以通过检查当前favicon.ico的最后修改日期来确保变更能让浏览器知道。</li></ul><h2 id="articleHeader19">&nbsp;cookie</h2><h3>&nbsp;</h3><h3 id="articleHeader25">25.给Cookie减肥</h3><p>　　使用cookie的原因有很多，比如授权和个性化。HTTP头中cookie信息在web服务器和浏览器之间交换。重要的是保证cookie尽可能的小，以最小化对用户响应时间的影响。</p><ul><li>清除不必要的cookie</li><li>保证cookie尽可能小，以最小化对用户响应时间的影响</li><li>注意给cookie设置合适的域级别，以免影响其它子域</li><li>设置合适的有效期，更早的有效期或者none可以更快的删除cookie，提高用户响应时间</li></ul><h3 id="articleHeader26">26.把组件放在不含cookie的域下</h3><p>　　当浏览器发送对静态图像的请求时，cookie也会一起发送，而服务器根本不需要这些cookie。所以它们只会造成没有意义的网络通信量，应该确保对静态组件的请求不含cookie。可以创建一个子域，把所有的静态组件都部署在那儿。</p><p>　　如果域名是<code>www.example.org</code>，可以把静态组件部署到<code>static.example.org</code>。然而，如果已经在顶级域<code>example.org</code>或者<code>www.example.org</code>设置了cookie，那么所有对<code>static.example.org</code>的请求都会含有这些cookie。这时候可以再买一个新域名，把所有的静态组件部署上去，并保持这个新域名不含cookie。Yahoo!用的是<code>yimg.com</code>，YouTube是<code>ytimg.com</code>，Amazon是<code>images-amazon.com</code>等等。</p><p>　　把静态组件部署在不含cookie的域下还有一个好处是有些代理可能会拒绝缓存带cookie的组件。有一点需要注意：如果不知道应该用example.org还是www.example.org作为主页，可以考虑一下cookie的影响。省略www的话，就只能把cookie写到<code>*.example.org</code>，所以因为性能原因最好用www子域，并且把cookie写到这个子域下。</p><h3>&nbsp;</h3><h2>移动端&nbsp;</h2><p>&nbsp;</p><h3 id="articleHeader35">27.保证所有组件都小于25K</h3><p>&nbsp;</p><p>　　这个限制是因为iPhone不能缓存大于25K的组件，注意这里指的是未压缩的大小。这就是为什么缩减内容本身也很重要，因为单纯的gzip可能不够。</p><p>&nbsp;</p><h3 id="articleHeader36">28.把组件打包到一个复合文档里</h3><p>&nbsp;</p><p>　　把各个组件打包成一个像有附件的电子邮件一样的复合文档里，可以用一个HTTP请求获取多个组件（记住一点：HTTP请求是代价高昂的）。用这种方式的时候，要先检查用户代理是否支持（iPhone就不支持）。</p><p>&nbsp;</p><h2>服务器</h2><p>&nbsp;</p><h3 id="articleHeader6">29.Gzip组件</h3><p>　　前端工程师可以想办法明显地缩短通过网络传输HTTP请求和响应的时间。毫无疑问，终端用户的带宽速度，网络服务商，对等交换点的距离等等，都是开发团队所无法控制的。但还有别的能够影响响应时间的因素，压缩可以通过减少HTTP响应的大小来缩短响应时间。</p><p>从HTTP/1.1开始，web客户端就有了支持压缩的Accept-Encoding HTTP请求头。</p><div><div id="highlighter_568538"><pre><code>Accept-Encoding: gzip, deflate</code></pre></div></div><p>　　如果web服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过Content-Encoding相应头来通知客户端。</p><div><div id="highlighter_956447"><pre><code>Content-Encoding: gzip</code></pre></div></div><p>　　尽可能多地用gzip压缩能够给页面减肥，这也是提升用户体验最简单的方法。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="articleHeader37">30.避免图片src属性为空</h3><p>Image with empty string&nbsp;<strong>src</strong>属性是空字符串的图片很常见，主要以两种形式出现：</p><ol><li>straight HTML<br><blockquote>&lt;img src=””&gt;</blockquote></li><li>JavaScript<br><blockquote>var img = new Image();<br>img.src = “”;</blockquote></li></ol><p>这两种形式都会引起相同的问题：浏览器会向服务器发送另一个请求。</p><p>　</p><h3 id="articleHeader15">31.配置ETags</h3><p>　　实体标签（ETags），是服务器和浏览器用来决定浏览器缓存中组件与源服务器中的组件是否匹配的一种机制（“实体”也就是组件：图片，脚本，样式表等等）。添加ETags可以提供一种实体验证机制，比最后修改日期更加灵活。一个ETag是一个字符串，作为一个组件某一具体版本的唯一标识符。唯一的格式约束是字符串必须用引号括起来，源服务器用相应头中的<code>ETag</code>来指定组件的ETag：</p><div><div id="highlighter_141382"><pre><code>HTTP/1.1 200 OK\n      Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT\n      ETag: "10c24bc-4ab-457e1c1f"\n      Content-Length: 12195</code></pre><p><br></p></div></div><p>　　然后，如果浏览器必须验证一个组件，它用<code>If-None-Match</code>请求头来把ETag传回源服务器。如果ETags匹配成功，会返回一个304状态码，这样就减少了12195个字节的响应体。</p><div><pre>GET /i/yahoo.gif HTTP/1.1\n      Host: us.yimg.com\n      If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT\n      If-None-Match: "10c24bc-4ab-457e1c1f"\n      HTTP/1.1 304 Not Modified</pre></div><p>　</p><p><strong>&nbsp;</strong></p><h3 id="articleHeader18">32.对Ajax用GET请求</h3><p>　　Yahoo!邮箱团队发现使用<code>XMLHttpRequest</code>时，浏览器的POST请求是通过一个两步的过程来实现的：先发送HTTP头，在发送数据。所以最好用GET请求，它只需要发送一个TCP报文（除非cookie特别多）。IE的URL长度最大值是2K，所以如果要发送的数据超过2K就无法使用GET了。</p><p>POST请求的一个有趣的副作用是实际上没有发送任何数据，就像GET请求一样。正如<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html" data-rapid_p="62">HTTP说明文档</a>中描述的，GET请求是用来检索信息的。所以它的语义只是用GET请求来请求数据，而不是用来发送需要存储到服务器的数据。</p><p>&nbsp;</p><p>&nbsp;</p><h3 id="articleHeader17">33.尽早清空缓冲区</h3><p>　当用户请求一个页面时，服务器需要用大约200到500毫秒来组装HTML页面，在这期间，浏览器闲等着数据到达。PHP中有一个<a href="http://php.net/flush" data-rapid_p="58">flush()</a>函数，允许给浏览器发送一部分已经准备完毕的HTML响应，以便浏览器可以在后台准备剩余部分的同时开始获取组件，好处主要体现在很忙的后台或者很“轻”的前端页面上（P.S. 也就是说，响应时耗主要在后台方面时最能体现优势）。</p><p>　　较理想的清空缓冲区的位置是HEAD后面，因为HTML的HEAD部分通常更容易生成，并且允许引入任何CSS和JavaScript文件，这样就可以让浏览器在后台还在处理的时候就开始并行获取组件。</p><p>例如：</p><div><pre> ... &lt;!-- css, js --&gt;\n    &lt;/head&gt;\n    &lt;?php flush(); ?&gt;\n    &lt;body&gt;\n      ... &lt;!-- content --&gt;</pre></div><p>&nbsp;</p><h3 id="articleHeader4">34.使用CDN（<strong>内容分发网络</strong>）</h3><p>　　用户与服务器的物理距离对响应时间也有影响。把内容部署在多个地理位置分散的服务器上能让用户更快地载入页面。但具体要怎么做呢？</p><p>　　实现内容在地理位置上分散的第一步是：不要尝试去重新设计你的web应用程序来适应分布式结构。这取决于应用程序，改变结构可能包括一些让人望而生畏的任务，比如同步会话状态和跨服务器复制数据库事务（翻译可能不准确）。缩短用户和内容之间距离的提议可能被推迟，或者根本不可能通过，就是因为这个难题。</p><p>　　记住终端用户80%到90%的响应时间都花在下载页面组件上了：图片，样式，脚本，Flash等等，这是业绩黄金法则。最好先分散静态内容，而不是一开始就重新设计应用程序结构。这不仅能够大大减少响应时间，还更容易表现出CDN的功劳。</p><p>　　内容分发网络（CDN）是一组分散在不同地理位置的web服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数（hop）最少的或者响应时间最快的服务器。</p><p>&nbsp;</p><h3 id="articleHeader5">35.添上Expires或者Cache-Control HTTP头</h3><p>这条规则有两个方面：</p><ul><li>对于静态组件：通过设置一个遥远的将来时间作为<code>Expires</code>来实现永不失效</li><li>多余动态组件：用合适的<code>Cache-Control</code>HTTP头来让浏览器进行条件性的请求</li></ul><p>　　网页设计越来越丰富，这意味着页面里有更多的脚本，图片和Flash。站点的新访客可能还是不得不提交几个HTTP请求，但通过使用有效期能让组件变得可缓存，这避免了在接下来的浏览过程中不必要的HTTP请求。有效期HTTP头通常被用在图片上，但它们应该用在所有组件上，包括脚本、样式和Flash组件。</p><p>　　浏览器（和代理）用缓存来减少HTTP请求的数目和大小，让页面能够更快加载。web服务器通过有效期HTTP响应头来告诉客户端，页面的各个组件应该被缓存多久。用一个遥远的将来时间做有效期，告诉浏览器这个响应在2010年4月15日前不会改变。</p><div><div id="highlighter_119291"><pre><code>Expires: Thu, 15 Apr 2010 20:00:00 GMT</code></pre></div></div><p>如果你用的是Apache服务器，用ExpiresDefault指令来设置相对于当前日期的有效期。下面的例子设置了从请求时间起10年的有效期：</p><div><pre>ExpiresDefault "access plus 10 years"</pre></div>', '阅读目录内容部分css部分js部分javascript, css图片cookie移动端服务器摘要：无论是在工作中，还是在面试中，web前端性能的优化都是很重要的，那么我们进行优化需要从哪些方面入手呢？可以遵循雅虎的前端优化34条军规，不过现在已经是35条了，所以可以说是雅虎前端优化的35条军规。已分类，挺好的，这样对于优化有一个比较清晰的方向  内容部分尽量减少HTTP请求数　　80%的终端用户响应时间都花在了前端上，其中大部分时间都在下载页面上的各种组件：图片，样式表，脚本，Flash等等。减少组件数必然能够减少页面提交的HTTP请求数。这是让页面更快的关键。　　减少页面组件数的一种方式是简化页面设计。但有没有一种方法可以在构建复杂的页面同时加快响应时间呢？嗯，确实有鱼和熊掌兼得的办法。　　合并文件是通过把所有脚本放在一个文件中的方式来减少请求数的，当然，也可以合并所有的CSS。如果各个页面的脚本和样式不一样的话，合并文件就是一项比较麻烦的工作了，但把这个作为站点发布过程的一部分确实可以提高响应时间。　　CSS Sprites是减少图片请求数量的首选方式。把背景图片都整合到一张图片中，然后用CSS的background-image和background-position属性来定位要显示的部分。　　图像映射可以把多张图片合并成单张图片，总大小是一样的，但减少了请求数并加速了页面加载。图片映射只有在图像在页面中连续的时候才有用，比如导航条。给image map设置坐标的过程既无聊又容易出错，用image map来做导航也不容易，所以不推荐用这种方式。　　行内图片（Base64编码）用data: URL模式来把图片嵌入页面。这样会增加HTML文件的大小，把行内图片放在（缓存的）样式表中是个好办法，而且成功避免了页面变“重”。但目前主流浏览器并不能很好地支持行内图片。　　减少页面的HTTP请求数是个起点，这是提升站点首次访问速度的重要指导原则。 2.减少DNS查找　　域名系统建立了主机名和IP地址间的映射，就像电话簿上人名和号码的映射一样。当你在浏览器输入www.yahoo.com的时候，浏览器就会联系DNS解析器返回服务器的IP地址。DNS是有成本的，它需要20到120毫秒去查找给定主机名的IP地址。在DNS查找完成之前，浏览器无法从主机名下载任何东西。　　DNS查找被缓存起来更高效，由用户的ISP（网络服务提供商）或者本地网络存在一个特殊的缓存服务器上，但还可以缓存在个人用户的计算机上。DNS信息被保存在操作系统的DNS cache(微软Windows上的”DNS客户端服务”)里。大多数浏览器有独立于操作系统的自己的cache。只要浏览器在自己的cache里还保留着这条记录，它就不会向操作系统查询DNS。　　IE默认缓存DNS查找30分钟，写在DnsCacheTimeout注册表设置中。Firefox缓存1分钟，可以用network.dnsCacheExpiration配置项设置。(Fasterfox把缓存时间改成了1小时 P.S. Fasterfox是FF的一个提速插件)　　如果客户端的DNS cache是空的（包括浏览器的和操作系统的），DNS查找数等于页面上不同的主机名数，包括页面URL，图片，脚本文件，样式表，Flash对象等等组件中的主机名，减少不同的主机名就可以减少DNS查找。　　减少不同主机名的数量同时也减少了页面能够并行下载的组件数量，避免DNS查找削减了响应时间，而减少并行下载数量却增加了响应时间。我的原则是把组件分散在2到4个主机名下，这是同时减少DNS查找和允许高并发下载的折中方案。 3.避免重定向重定向用301和302状态码，下面是一个有301状态码的HTTP头：HTTP/1.1 301 Moved Permanently\n      Location: http://example.com/newuri\n      Content-Type: text/html　　浏览器会自动跳转到Location域指明的URL。重定向需要的所有信息都在HTTP头部，而响应体一般是空的。其实额外的HTTP头，比如Expires和Cache-Control也表示重定向。除此之外还有别的跳转方式：refresh元标签和JavaScript，但如果你必须得做重定向，最好用标准的3xxHTTP状态码，主要是为了让返回按钮能正常使用。　　牢记重定向会拖慢用户体验，在用户和HTML文档之间插入重定向会延迟页面上的所有东西，页面无法渲染，组件也无法开始下载，直到HTML文档被送达浏览器。　　有一种常见的极其浪费资源的重定向，而且web开发人员一般都意识不到这一点，就是URL尾部缺少一个斜线的时候。例如，跳转到http://astrology.yahoo.com/astrology会返回一个重定向到http://astrology.yahoo.com/astrology/的301响应（注意添在尾部的斜线）。在Apache中可以用Alias，mod_rewrite或者DirectorySlash指令来取消不必要的重定向。　　重定向最常见的用途是把旧站点连接到新的站点，还可以连接同一站点的不同部分，针对用户的不同情况（浏览器类型，用户帐号类型等等）做一些处理。用重定向来连接两个网站是最简单的，只需要少量的额外代码。虽然在这些时候使用重定向减少了开发人员的开发复杂度，但降低了用户体验。一种替代方案是用Alias和mod_rewrite，前提是两个代码路径都在相同的服务器上。如果是因为域名变化而使用了重定向，就可以创建一条CNAME（创建一个指向另一个域名的DNS记录作为别名）结合Alias或者mod_rewrite指令。 4.让Ajax可缓存　　Ajax的一个好处是可以给用户提供即时反馈，因为它能够从后台服务器异步请求信息。然而，用了Ajax就无法保证用户在等待异步JavaScript和XML响应返回期间不会非常无聊。在很多应用程序中，用户能够一直等待取决于如何使用Ajax。例如，在基于web的电子邮件客户端中，用户为了寻找符合他们搜索标准的邮件消息，将会保持对Ajax请求返回结果的关注。重要的是，要记得“异步”并不意味着“即时”。　　要提高性能，优化这些Ajax响应至关重要。最重要的提高Ajax性能的方法就是让响应变得可缓存，就像在添上Expires或者Cache-Control HTTP头中讨论的一样。下面适用于Ajax的其它规则：Gzip组件减少DNS查找压缩JavaScript避免重定向配置ETags　　我们一起看看例子，一个Web 2.0的电子邮件客户端用了Ajax来下载用户的通讯录，以便实现自动完成功能。如果用户从上一次使用之后再没有修改过她的通讯录，而且Ajax响应是可缓存的，有尚未过期的Expires或者Cache-Control HTTP头，那么之前的通讯录就可以从缓存中读出。必须通知浏览器，应该继续使用之前缓存的通讯录响应，还是去请求一个新的。可以通过给通讯录的Ajax URL里添加一个表明用户通讯录最后修改时间的时间戳来实现，例如&amp;t=1190241612。如果通讯录从上一次下载之后再没有被修改过，时间戳不变，通讯录就将从浏览器缓存中直接读出，从而避免一次额外的HTTP往返消耗。如果用户已经修改了通讯录，时间戳也可以确保新的URL不会匹配缓存的响应，浏览器将请求新的通讯录条目。　　即使Ajax响应是动态创建的，而且可能只适用于单用户，它们也可以被缓存，而这样会让你的Web 2.0应用更快。 5.延迟加载组件　　可以凑近看看页面并问自己：什么才是一开始渲染页面所必须的？其余内容都可以等会儿。　　JavaScript是分隔onload事件之前和之后的一个理想选择。例如，如果有JavaScript代码和支持拖放以及动画的库，这些都可以先等会儿，因为拖放元素是在页面最初渲染之后的。其它可以延迟加载的部分包括隐藏内容（在某个交互动作之后才出现的内容）和折叠的图片。　　工具可帮你减轻工作量：YUI Image Loader可以延迟加载折叠的图片，还有YUI Get utility是一种引入JS和CSS的简单方法。Yahoo!主页就是一个例子，可以打开Firebug的网络面板仔细看看。　　最好让性能目标符合其它web开发最佳实践，比如“渐进增强”。如果客户端支持JavaScript，可以提高用户体验，但必须确保页面在不支持JavaScript时也能正常工作。所以，在确定页面运行正常之后，可以用一些延迟加载脚本增强它，以支持一些拖放和动画之类的华丽效果。 6.预加载组件　　预加载可能看起来和延迟加载是相反的，但它其实有不同的目标。通过预加载组件可以充分利用浏览器空闲的时间来请求将来会用到的组件（图片，样式和脚本）。用户访问下一页的时候，大部分组件都已经在缓存里了，所以在用户看来页面会加载得更快。实际应用中有以下几种预加载的类型：无条件预加载——尽快开始加载，获取一些额外的组件。google.com就是一个sprite图片预加载的好例子，这个sprite图片并不是google.com主页需要的，而是搜索结果页面上的内容。条件性预加载——根据用户操作猜测用户将要跳转到哪里并据此预加载。在search.yahoo.com的输入框里键入内容后，可以看到那些额外组件是怎样请求加载的。提前预加载——在推出新设计之前预加载。经常在重新设计之后会听到：“这个新网站不错，但比以前更慢了”，一部分原因是用户访问先前的页面都是有旧缓存的，但新的却是一种空缓存状态下的体验。可以通过在将要推出新设计之前预加载一些组件来减轻这种负面影响，老站可以利用浏览器空闲的时间来请求那些新站需要的图片和脚本。 7.减少DOM元素的数量　　一个复杂的页面意味着要下载更多的字节，而且用JavaScript访问DOM也会更慢。举个例子，想要添加一个事件处理器的时候，循环遍历页面上的500个DOM元素和5000个DOM元素是有区别的。　　大量的DOM元素是一种征兆——页面上有些内容无关的标记需要清理。正在用嵌套表格来布局吗？还是为了修复布局问题而添了一堆的&lt;div&gt;s？或许应该用更好的语义化标记。YUI CSS utilities对布局有很大帮助：grids.css针对整体布局，fonts.css和reset.css可以用来去除浏览器的默认格式。这是个开始清理和思考标记的好机会，例如只在语义上有意义的时候使用&lt;div&gt;，而不是因为它能够渲染一个新行。　　DOM元素的数量很容易测试，只需要在Firebug的控制台里输入：document.getElementsByTagName(''*'').length 　　那么多少DOM元素才算是太多呢？可以参考其它类似的标记良好的页面，例如Yahoo!主页是一个相当繁忙的页面，但只有不到700个元素（HTML标签）。 8.跨域分离组件　　分离组件可以最大化并行下载，但要确保只用不超过2-4个域，因为存在DNS查找的代价。例如，可以把HTML和动态内容部署在www.example.org，而把静态组件分离到static1.example.org和static2.example.org。 9.尽量少用iframe　　用iframe可以把一个HTML文档插入到父文档里，重要的是明白iframe是如何工作的并高效地使用它。&lt;iframe&gt;的优点：引入缓慢的第三方内容，比如标志和广告安全沙箱并行下载脚本&lt;iframe&gt;的缺点：代价高昂，即使是空白的iframe阻塞页面加载非语义 10.杜绝404　　HTTP请求代价高昂，完全没有必要用一个HTTP请求去获取一个无用的响应（比如404 Not Found），只会拖慢用户体验而没有任何好处。　　有些站点用的是有帮助的404——“你的意思是xxx？”，这样做有利于用户体验，，但也浪费了服务器资源（比如数据库等等）。最糟糕的是链接到的外部JavaScript有错误而且结果是404。首先，这种下载将阻塞并行下载。其次，浏览器会试图解析404响应体，因为它是JavaScript代码，需要找出其中可用的部分。 css部分 11.避免使用CSS表达式 用CSS表达式动态设置CSS属性，是一种强大又危险的方式。从IE5开始支持，但从IE8起就不推荐使用了。例如，可以用CSS表达式把背景颜色设置成按小时交替的：1background-color: expression( (new Date()).getHours()%2 ? "#B8D4FF" : "#F08A00" ); 12.选择&lt;link&gt;舍弃@import　　前面提到了一个最佳实践：为了实现逐步渲染，CSS应该放在顶部。  在IE中用@import与在底部用&lt;link&gt;效果一样，所以最好不要用它。 13.避免使用滤镜　　IE专有的AlphaImageLoader滤镜可以用来修复IE7之前的版本中半透明PNG图片的问题。在图片加载过程中，这个滤镜会阻塞渲染，卡住浏览器，还会增加内存消耗而且是被应用到每个元素的，而不是每个图片，所以会存在一大堆问题。最好的方法是干脆不要用AlphaImageLoader，而优雅地降级到用在IE中支持性很好的PNG8图片来代替。如果非要用AlphaImageLoader，应该用下划线hack：_filter来避免影响IE7及更高版本的用户。 14.把样式表放在顶部　　在Yahoo!研究性能的时候，我们发现把样式表放到文档的HEAD部分能让页面看起来加载地更快。这是因为把样式表放在head里能让页面逐步渲染。　　关注性能的前端工程师想让页面逐步渲染。也就是说，我们想让浏览器尽快显示已有内容，这在页面上有一大堆内容或者用户网速很慢时显得尤为重要。给用户显示反馈（比如进度指标）的重要性已经被广泛研究过，并且被记录下来了。在我们的例子中，HTML页面就是进度指标！当浏览器逐渐加载页面头部，导航条，顶部logo等等内容的时候，这些都被正在等待页面加载的用户当作反馈，能够提高整体用户体验。 js部分 15.去除重复脚本　　页面含有重复的脚本文件会影响性能，这可能和你想象的不一样。在对美国前10大web站点的评审中，发现只有2个站点含有重复脚本。两个主要原因增加了在单一页面中出现重复脚本的几率：团队大小和脚本数量。在这种情况下，重复脚本会创建不必要的HTTP请求，执行无用的JavaScript代码，而影响页面性能。　　IE会产生不必要的HTTP请求，而Firefox不会。在IE中，如果一个不可缓存的外部脚本被页面引入了两次，它会在页面加载时产生两个HTTP请求。即使脚本是可缓存的，在用户重新加载页面时也会产生额外的HTTP请求。　　除了产生没有意义的HTTP请求之外，多次对脚本求值也会浪费时间。因为无论脚本是否可缓存，在Firefox和IE中都会执行冗余的JavaScript代码。　　避免不小心把相同脚本引入两次的一种方法就是在模版系统中实现脚本管理模块。典型的脚本引入方法就是在HTML页面中用SCRIPT标签：&lt;script type="text/javascript" src="menu_1.0.17.js"&gt;&lt;/script&gt;16.尽量减少DOM访问用JavaScript访问DOM元素是很慢的，所以，为了让页面反应更迅速，应该：缓存已访问过的元素的索引先“离线”更新节点，再把它们添到DOM树上避免用JavaScript修复布局问题 17.用智能的事件处理器　　有时候感觉页面反映不够灵敏，是因为有太多频繁执行的事件处理器被添加到了DOM树的不同元素上，这就是推荐使用事件委托的原因。如果一个div里面有10个按钮，应该只给div容器添加一个事件处理器，而不是给每个按钮都添加一个。事件能够冒泡，所以可以捕获事件并得知哪个按钮是事件源。 18.把脚本放在底部　　脚本会阻塞并行下载，HTTP/1.1官方文档建议浏览器每个主机名下并行下载的组件数不要超过两个，如果图片来自多个主机名，并行下载的数量就可以超过两个。如果脚本正在下载，浏览器就不开始任何其它下载任务，即使是在不同主机名下的。　　有时候，并不容易把脚本移动到底部。举个例子，如果脚本是用document.write插入到页面内容中的，就没办法再往下移了。还可能存在作用域问题，在多数情况下，这些问题都是可以解决的。　　一个常见的建议是用推迟（deferred）脚本，有DEFER属性的脚本意味着不能含有document.write，并且提示浏览器告诉他们可以继续渲染。不幸的是，Firefox不支持DEFER属性。在IE中，脚本可能被推迟，但不尽如人意。如果脚本可以推迟，我们就可以把它放到页面底部，页面就可以更快地载入。javascript, css  19.把JavaScript和CSS放到外面　　很多性能原则都是关于如何管理外部组件的，然而，在这些顾虑出现之前你应该问一个更基础的问题：应该把JavaScript和CSS放到外部文件中还是直接写在页面里？实际上，用外部文件可以让页面更快，因为JavaScript和CSS文件会被缓存在浏览器。HTML文档中的行内JavaScript和CSS在每次请求该HTML文档的时候都会重新下载。这样做减少了所需的HTTP请求数，但增加了HTML文档的大小。另一方面，如果JavaScript和CSS在外部文件中，并且已经被浏览器缓存起来了，那么我们就成功地把HTML文档变小了，而且还没有增加HTTP请求数。　　20.压缩JavaScript和CSS　　压缩具体来说就是从代码中去除不必要的字符以减少大小，从而提升加载速度。代码最小化就是去掉所有注释和不必要的空白字符（空格，换行和tab）。在JavaScript中这样做能够提高响应性能，因为要下载的文件变小了。两个最常用的JavaScript代码压缩工具是JSMin和YUI Compressor，YUI compressor还可以压缩CSS。　　混淆是一种可选的源码优化措施，要比压缩更复杂，所以混淆过程也更容易产生bug。在对美国前十的网站调查中，压缩可以缩小21%，而混淆能缩小25%。虽然混淆的缩小程度更高，但比压缩风险更大。　　除了压缩外部脚本和样式，行内的&lt;script&gt;和&lt;style&gt;块也可以压缩。即使启用了gzip模块，先进行压缩也能够缩小5%或者更多的大小。JavaScript和CSS的用处越来越多，所以压缩代码会有不错的效果。图片 21.优化图片尝试把GIF格式转换成PNG格式，看看是否节省空间。在所有的PNG图片上运行pngcrush（或者其它PNG优化工具） 22.优化CSS Sprite在Sprite图片中横向排列一般都比纵向排列的最终文件小组合Sprite图片中的相似颜色可以保持低色数，最理想的是256色以下PNG8格式“对移动端友好”，不要在Sprite图片中留下太大的空隙。虽然不会在很大程度上影响图片文件的大小，但这样做可以节省用户代理把图片解压成像素映射时消耗的内存。100×100的图片是1万个像素，而1000×1000的图片就是100万个像素了。 23.不要用HTML缩放图片　　不要因为在HTML中可以设置宽高而使用本不需要的大图。如果需要&lt;img width="100" height="100" src="mycat.jpg" alt="My Cat" /&gt;　　那么图片本身（mycat.jpg）应该是100x100px的，而不是去缩小500x500px的图片。 24.用小的可缓存的favicon.ico（P.S. 收藏夹图标）　　favicon.ico是放在服务器根目录的图片，它会带来一堆麻烦，因为即便你不管它，浏览器也会自动请求它，所以最好不要给一个404 Not Found响应。而且只要在同一个服务器上，每次请求它时都会发送cookie，此外这个图片还会干扰下载顺序，例如在IE中，当你在onload中请求额外组件时，将会先下载favicon。所以为了缓解favicon.ico的缺点，应该确保：足够小，最好在1K以下设置合适的有效期HTTP头（以后如果想换的话就不能重命名了），把有效期设置为几个月后一般比较安全，可以通过检查当前favicon.ico的最后修改日期来确保变更能让浏览器知道。 cookie 25.给Cookie减肥　　使用cookie的原因有很多，比如授权和个性化。HTTP头中cookie信息在web服务器和浏览器之间交换。重要的是保证cookie尽可能的小，以最小化对用户响应时间的影响。清除不必要的cookie保证cookie尽可能小，以最小化对用户响应时间的影响注意给cookie设置合适的域级别，以免影响其它子域设置合适的有效期，更早的有效期或者none可以更快的删除cookie，提高用户响应时间26.把组件放在不含cookie的域下　　当浏览器发送对静态图像的请求时，cookie也会一起发送，而服务器根本不需要这些cookie。所以它们只会造成没有意义的网络通信量，应该确保对静态组件的请求不含cookie。可以创建一个子域，把所有的静态组件都部署在那儿。　　如果域名是www.example.org，可以把静态组件部署到static.example.org。然而，如果已经在顶级域example.org或者www.example.org设置了cookie，那么所有对static.example.org的请求都会含有这些cookie。这时候可以再买一个新域名，把所有的静态组件部署上去，并保持这个新域名不含cookie。Yahoo!用的是yimg.com，YouTube是ytimg.com，Amazon是images-amazon.com等等。　　把静态组件部署在不含cookie的域下还有一个好处是有些代理可能会拒绝缓存带cookie的组件。有一点需要注意：如果不知道应该用example.org还是www.example.org作为主页，可以考虑一下cookie的影响。省略www的话，就只能把cookie写到*.example.org，所以因为性能原因最好用www子域，并且把cookie写到这个子域下。 移动端  27.保证所有组件都小于25K 　　这个限制是因为iPhone不能缓存大于25K的组件，注意这里指的是未压缩的大小。这就是为什么缩减内容本身也很重要，因为单纯的gzip可能不够。 28.把组件打包到一个复合文档里 　　把各个组件打包成一个像有附件的电子邮件一样的复合文档里，可以用一个HTTP请求获取多个组件（记住一点：HTTP请求是代价高昂的）。用这种方式的时候，要先检查用户代理是否支持（iPhone就不支持）。 服务器 29.Gzip组件　　前端工程师可以想办法明显地缩短通过网络传输HTTP请求和响应的时间。毫无疑问，终端用户的带宽速度，网络服务商，对等交换点的距离等等，都是开发团队所无法控制的。但还有别的能够影响响应时间的因素，压缩可以通过减少HTTP响应的大小来缩短响应时间。从HTTP/1.1开始，web客户端就有了支持压缩的Accept-Encoding HTTP请求头。Accept-Encoding: gzip, deflate　　如果web服务器看到这个请求头，它就会用客户端列出的一种方式来压缩响应。web服务器通过Content-Encoding相应头来通知客户端。Content-Encoding: gzip　　尽可能多地用gzip压缩能够给页面减肥，这也是提升用户体验最简单的方法。  30.避免图片src属性为空Image with empty string src属性是空字符串的图片很常见，主要以两种形式出现：straight HTML&lt;img src=””&gt;JavaScriptvar img = new Image();img.src = “”;这两种形式都会引起相同的问题：浏览器会向服务器发送另一个请求。　31.配置ETags　　实体标签（ETags），是服务器和浏览器用来决定浏览器缓存中组件与源服务器中的组件是否匹配的一种机制（“实体”也就是组件：图片，脚本，样式表等等）。添加ETags可以提供一种实体验证机制，比最后修改日期更加灵活。一个ETag是一个字符串，作为一个组件某一具体版本的唯一标识符。唯一的格式约束是字符串必须用引号括起来，源服务器用相应头中的ETag来指定组件的ETag：HTTP/1.1 200 OK\n      Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT\n      ETag: "10c24bc-4ab-457e1c1f"\n      Content-Length: 12195　　然后，如果浏览器必须验证一个组件，它用If-None-Match请求头来把ETag传回源服务器。如果ETags匹配成功，会返回一个304状态码，这样就减少了12195个字节的响应体。GET /i/yahoo.gif HTTP/1.1\n      Host: us.yimg.com\n      If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT\n      If-None-Match: "10c24bc-4ab-457e1c1f"\n      HTTP/1.1 304 Not Modified　 32.对Ajax用GET请求　　Yahoo!邮箱团队发现使用XMLHttpRequest时，浏览器的POST请求是通过一个两步的过程来实现的：先发送HTTP头，在发送数据。所以最好用GET请求，它只需要发送一个TCP报文（除非cookie特别多）。IE的URL长度最大值是2K，所以如果要发送的数据超过2K就无法使用GET了。POST请求的一个有趣的副作用是实际上没有发送任何数据，就像GET请求一样。正如HTTP说明文档中描述的，GET请求是用来检索信息的。所以它的语义只是用GET请求来请求数据，而不是用来发送需要存储到服务器的数据。  33.尽早清空缓冲区　当用户请求一个页面时，服务器需要用大约200到500毫秒来组装HTML页面，在这期间，浏览器闲等着数据到达。PHP中有一个flush()函数，允许给浏览器发送一部分已经准备完毕的HTML响应，以便浏览器可以在后台准备剩余部分的同时开始获取组件，好处主要体现在很忙的后台或者很“轻”的前端页面上（P.S. 也就是说，响应时耗主要在后台方面时最能体现优势）。　　较理想的清空缓冲区的位置是HEAD后面，因为HTML的HEAD部分通常更容易生成，并且允许引入任何CSS和JavaScript文件，这样就可以让浏览器在后台还在处理的时候就开始并行获取组件。例如： ... &lt;!-- css, js --&gt;\n    &lt;/head&gt;\n    &lt;?php flush(); ?&gt;\n    &lt;body&gt;\n      ... &lt;!-- content --&gt; 34.使用CDN（内容分发网络）　　用户与服务器的物理距离对响应时间也有影响。把内容部署在多个地理位置分散的服务器上能让用户更快地载入页面。但具体要怎么做呢？　　实现内容在地理位置上分散的第一步是：不要尝试去重新设计你的web应用程序来适应分布式结构。这取决于应用程序，改变结构可能包括一些让人望而生畏的任务，比如同步会话状态和跨服务器复制数据库事务（翻译可能不准确）。缩短用户和内容之间距离的提议可能被推迟，或者根本不可能通过，就是因为这个难题。　　记住终端用户80%到90%的响应时间都花在下载页面组件上了：图片，样式，脚本，Flash等等，这是业绩黄金法则。最好先分散静态内容，而不是一开始就重新设计应用程序结构。这不仅能够大大减少响应时间，还更容易表现出CDN的功劳。　　内容分发网络（CDN）是一组分散在不同地理位置的web服务器，用来给用户更高效地发送内容。典型地，选择用来发送内容的服务器是基于网络距离的衡量标准的。例如：选跳数（hop）最少的或者响应时间最快的服务器。 35.添上Expires或者Cache-Control HTTP头这条规则有两个方面：对于静态组件：通过设置一个遥远的将来时间作为Expires来实现永不失效多余动态组件：用合适的Cache-ControlHTTP头来让浏览器进行条件性的请求　　网页设计越来越丰富，这意味着页面里有更多的脚本，图片和Flash。站点的新访客可能还是不得不提交几个HTTP请求，但通过使用有效期能让组件变得可缓存，这避免了在接下来的浏览过程中不必要的HTTP请求。有效期HTTP头通常被用在图片上，但它们应该用在所有组件上，包括脚本、样式和Flash组件。　　浏览器（和代理）用缓存来减少HTTP请求的数目和大小，让页面能够更快加载。web服务器通过有效期HTTP响应头来告诉客户端，页面的各个组件应该被缓存多久。用一个遥远的将来时间做有效期，告诉浏览器这个响应在2010年4月15日前不会改变。Expires: Thu, 15 Apr 2010 20:00:00 GMT如果你用的是Apache服务器，用ExpiresDefault指令来设置相对于当前日期的有效期。下面的例子设置了从请求时间起10年的有效期：ExpiresDefault "access plus 10 years"', 1, 0, 62, 8, 1, 1),
(22, '浏览器中输入url后发生了什么', 'Dreammin_chen（简书', '2017-11-08 12:31:13', '2017-11-04 14:38:32', '<p>在学习前端的过程中经常看到这样一个问题：当你在浏览器中输入url后发生了什么？下面是个人学习过程中的总结，供个人复习使用，如有理解不正确或不足的地方希望大家指出。<br>先上一张脑图：<br></p><img src="http://upload-images.jianshu.io/upload_images/2075673-3afda32a13a68c6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"><br><p><br></p><p><br></p><p>我将该过程分为了以下六步：</p><h3>1. DNS域名解析</h3><ul><li>在浏览器DNS缓存中搜索</li><li>在操作系统DNS缓存中搜索</li><li>读取系统hosts文件，查找其中是否有对应的ip</li><li>向本地配置的首选DNS服务器发起域名解析请求</li></ul><h3>2. 建立TCP连接</h3><p>为了准确地传输数据，TCP协议采用了三次握手策略。发送端首先发送一个带 SYN（synchronize）标志的数据包给接收方，接收方收到后，回传一个带有SYN/ACK(acknowledegment)标志的数据包以示传达确认信息。最后发送方再回传一个带ACK标志的数据包，代表握手结束。在这过程中若出现问题中断，TCP会再次发送相同的数据包&nbsp;</p><p>TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。&nbsp;&nbsp;<br></p><h3>3. 发起HTTP请求</h3><p>请求方法：</p><ul><li>GET:获取资源</li><li>POST:传输实体主体</li><li>HEAD:获取报文首部</li><li>PUT:传输文件</li><li>DELETE:删除文件</li><li>OPTIONS:询问支持的方法</li><li><p>TRACE:追踪路径</p><p>请求报文：</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/2075673-1f2c0829b7a86c6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width:100%;"><br></p><h3>4. 接受响应结果</h3><p>状态码：</p><ul><li>1**：信息性状态码</li><li>2**：成功状态码&nbsp;<br></li></ul><p>&nbsp;&nbsp;&nbsp;&nbsp;200：OK 请求正常处理&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;204：No Content请求处理成功，但没有资源可返回&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;206：Partial Content对资源的某一部分的请求&nbsp;</p><p>3**：重定向状态码&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;301：Moved Permanently 永久重定向&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;302：Found 临时性重定向&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;304：Not Modified 缓存中读取&nbsp;</p><p>4**：客户端错误状态码&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;400：Bad Request 请求报文中存在语法错误&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;401：Unauthorized需要有通过Http认证的认证信息&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;403：Forbidden访问被拒绝&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;404：Not Found无法找到请求资源&nbsp;</p><p>5**：服务器错误状态码&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;500：Internal Server Error 服务器端在执行时发生错误&nbsp;</p><p>&nbsp;&nbsp;&nbsp;&nbsp;503：Service Unavailable 服务器处于超负载或者正在进行停机维护</p><p>响应报文：&nbsp;</p><p><img src="http://upload-images.jianshu.io/upload_images/2075673-a7d5616fac0adec7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width: 100%;"></p><p><br></p><h3>5. 浏览器解析html</h3><p>浏览器按顺序解析html文件，构建DOM树，在解析到外部的css和js文件时，向服务器发起请求下载资源，若是下载css文件，则解析器会在下载的同时继续解析后面的html来构建DOM树，则在下载js文件和执行它时，解析器会停止对html的解析。这便出现了js阻塞问题。&nbsp;</p><p><strong>预加载器</strong>：&nbsp;<br></p><p>当浏览器被脚本文件阻塞时，预加载器（一个轻量级的解析器）会继续解析后面的html，寻找需要下载的资源。如果发现有需要下载的资源，预加载器在开始接收这些资源。预加载器只能检索HTML标签中的URL，无法检测到使用脚本添加的URL，这些资源要等脚本代码执行时才会获取。&nbsp;</p><p>注: 预解析并不改变Dom树，它将这个工作留给主解析过程</p><p>浏览器解析css，形成CSSOM树，当DOM树构建完成后，浏览器引擎通过DOM树和CSSOM树构造出渲染树。渲染树中包含可视节点的样式信息（不可见节点将不会被添加到渲染树中，如：head元素和display值为none的元素）</p><blockquote><span style="background-color: rgb(255, 255, 255);">值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</span>&nbsp;</blockquote><h3>6. 浏览器布局渲染</h3><ul><li>布局：通过计算得到每个渲染对象在可视区域中的具体位置信息（大小和位置），这是一个递归的过程。</li><li>绘制：将计算好的每个像素点信息绘制在屏幕上</li></ul><p>在页面显示的过程中会多次进行Reflow和Repaint操作，而Reflow的成本比Repaint的成本高得多的多。因为Repaint只是将某个部分进行重新绘制而不用改变页面的布局，如：&nbsp;</p><p>改变了某个元素的背景颜色。而如果将元素的display属性由block改为none则需要Reflow。</p><p><img src="http://upload-images.jianshu.io/upload_images/2075673-e6b92f5c6c8c50d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style="max-width: 100%;">&nbsp;</p>', '在学习前端的过程中经常看到这样一个问题：当你在浏览器中输入url后发生了什么？下面是个人学习过程中的总结，供个人复习使用，如有理解不正确或不足的地方希望大家指出。先上一张脑图：我将该过程分为了以下六步：1. DNS域名解析在浏览器DNS缓存中搜索在操作系统DNS缓存中搜索读取系统hosts文件，查找其中是否有对应的ip向本地配置的首选DNS服务器发起域名解析请求2. 建立TCP连接为了准确地传输数据，TCP协议采用了三次握手策略。发送端首先发送一个带 SYN（synchronize）标志的数据包给接收方，接收方收到后，回传一个带有SYN/ACK(acknowledegment)标志的数据包以示传达确认信息。最后发送方再回传一个带ACK标志的数据包，代表握手结束。在这过程中若出现问题中断，TCP会再次发送相同的数据包 TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。  3. 发起HTTP请求请求方法：GET:获取资源POST:传输实体主体HEAD:获取报文首部PUT:传输文件DELETE:删除文件OPTIONS:询问支持的方法TRACE:追踪路径请求报文：4. 接受响应结果状态码：1**：信息性状态码2**：成功状态码     200：OK 请求正常处理     204：No Content请求处理成功，但没有资源可返回     206：Partial Content对资源的某一部分的请求 3**：重定向状态码     301：Moved Permanently 永久重定向     302：Found 临时性重定向     304：Not Modified 缓存中读取 4**：客户端错误状态码     400：Bad Request 请求报文中存在语法错误     401：Unauthorized需要有通过Http认证的认证信息     403：Forbidden访问被拒绝     404：Not Found无法找到请求资源 5**：服务器错误状态码     500：Internal Server Error 服务器端在执行时发生错误     503：Service Unavailable 服务器处于超负载或者正在进行停机维护响应报文： 5. 浏览器解析html浏览器按顺序解析html文件，构建DOM树，在解析到外部的css和js文件时，向服务器发起请求下载资源，若是下载css文件，则解析器会在下载的同时继续解析后面的html来构建DOM树，则在下载js文件和执行它时，解析器会停止对html的解析。这便出现了js阻塞问题。 预加载器： 当浏览器被脚本文件阻塞时，预加载器（一个轻量级的解析器）会继续解析后面的html，寻找需要下载的资源。如果发现有需要下载的资源，预加载器在开始接收这些资源。预加载器只能检索HTML标签中的URL，无法检测到使用脚本添加的URL，这些资源要等脚本代码执行时才会获取。 注: 预解析并不改变Dom树，它将这个工作留给主解析过程浏览器解析css，形成CSSOM树，当DOM树构建完成后，浏览器引擎通过DOM树和CSSOM树构造出渲染树。渲染树中包含可视节点的样式信息（不可见节点将不会被添加到渲染树中，如：head元素和display值为none的元素）值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。 6. 浏览器布局渲染布局：通过计算得到每个渲染对象在可视区域中的具体位置信息（大小和位置），这是一个递归的过程。绘制：将计算好的每个像素点信息绘制在屏幕上在页面显示的过程中会多次进行Reflow和Repaint操作，而Reflow的成本比Repaint的成本高得多的多。因为Repaint只是将某个部分进行重新绘制而不用改变页面的布局，如： 改变了某个元素的背景颜色。而如果将元素的display属性由block改为none则需要Reflow。 ', 1, 0, 0, 7, 1, 1),
(23, 'DOM树知识点梳理', 'ouyangyanlan（CSD', '2017-11-08 12:31:10', '2017-11-04 14:55:05', '<p>为什么会提到Dom树呢，或许它对于我们很好地理解网页各个元素，标签和控件搭配，以及各种js，css等的加载会有一些帮助。笔者在工程中遇到了一些小问题，本质就是dom树的东西掌握的不扎实。所以借此来梳理一下。&nbsp;<br>1.HTML DOM&nbsp;<br>ok, 我们先来看一下W3school中怎么解释这个概念和结构的。W3school是一个很不错的网站，很适合初学者和基础不扎实的人。</p><p>HTML DOM 定义了访问和操作 HTML 文档的标准方法。DOM 将 HTML 文档表达为树结构。&nbsp;</p><p><img src="http://img.blog.csdn.net/20151110111104365" style="max-width:100%;"><br></p><p>W3C 文档对象模型 （DOM） 是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。&nbsp;<br>W3C DOM 标准被分为 3 个不同的部分：&nbsp;<br>核心 DOM - 针对任何结构化文档的标准模型&nbsp;<br>XML DOM - 针对 XML 文档的标准模型&nbsp;<br>HTML DOM - 针对 HTML 文档的标准模型&nbsp;<br>我们主要来看HTML DOM&nbsp;<br>HTML DOM 是：&nbsp;<br>HTML 的标准对象模型&nbsp;<br>HTML 的标准编程接口&nbsp;<br>W3C 标准</p><p>DOM 节点&nbsp;<br>根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点：&nbsp;<br>整个文档是一个文档节点&nbsp;<br>每个 HTML 元素是元素节点&nbsp;<br>HTML 元素内的文本是文本节点&nbsp;<br>每个 HTML 属性是属性节点&nbsp;<br>注释是注释节点&nbsp;</p><p><img src="http://img.blog.csdn.net/20151110111711483" style="max-width:100%;"><br></p><p>2.获取节点的原生方法</p><p><img src="http://img.blog.csdn.net/20151110113005658" alt="这里写图片描述" title=""></p><p>3.JS中的节点操作&nbsp;<br>写几个常用的API, 来操作DOM节点。&nbsp;<br>(1)document.getElementById()这个是最基本的了。&nbsp;<br>(2)object.innerHTML该属性设置或返回object之间的HTML&nbsp;<br>(3)document.createElement()创建节点对象。&nbsp;<br>(4)document.body.appendChild()尾部插入结点。&nbsp;<br>(5)object.parentNode.removeChild(oChildNode);移除结点</p><p>4.jQuery中的结点操作&nbsp;<br>(1)添加结点&nbsp;<br>a. append()和appendTo(), 两个方法刚好是对应的一对儿操作。</p><pre><code>$(''#parentNodeId'').append(childNode);</code></pre><pre><code>$(''#childeNode'').appendTo(parentNode);</code></pre><p>b. prepend()和prependTo()， 这也是一对儿对应的操作方法。其作用是添加一个结点到父节点中并前置。用法和上一对儿一样。</p><p>c. 与之对应的还有after, insertAfter; before, insertBefore等，其用法都和上面的相同。其效果是将新建的元素插入到指定的元素之后/前，并和目标元素紧邻，作为兄弟结点存在。</p><p>(2)删除结点&nbsp;<br>a. remove()&nbsp;<br>remove()方法删除所有匹配的元素，传入的参数用于筛选元素，该方法可以删除元素中所有的子节点，当匹配的节点及后代被删除后，该方法返回值是指向被删除结点的引用，因此可以使用该引用，再使用被删除的元素。<span style="background-color: rgb(241, 241, 241); color: inherit; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: inherit; white-space: pre-wrap;">$span = $(''span'').remove();</span></p><pre><code>$span = $(''span'').remove();\n$span.insertAfter(''ul'');</code></pre><p>我们可以看到，该示例中，先删除所有的span元素，把删除的元素使用$span接收，把删除后的元素添加到ul后面，作为ul的兄弟结点。该操作产生的效果即把所有的span元素以及后代元素移到ul后面。&nbsp;<br>b. empty()&nbsp;<br>empty()方法严格来讲并不是删除元素，该方法只是清空节点，它能清空元素中的所有子节点。</p><p>(3)修改DOM节点&nbsp;<br>a. 复制节点，当clone()方法有参数，并且为true时，表示同时复制该元素的属性，如果没有参数，表示不复制属性。</p><pre><code>$(element).clone(true);</code></pre><p>b.替换节点&nbsp;<br>这两个方法都可以实现替换节点的问题。&nbsp;</p><pre><code>$(element).replacewith();\n$(element).replaceAll();</code></pre><p>c.包裹节点&nbsp;</p><pre><code>$(element).wrap()\n$(element).wrapAll()\n$(element).wraplnner()</code></pre><p>(4)属性操作&nbsp;<br>attr()和removeAttr()。 attr()方法能够获取元素属性，也能够设置元素属性。removeAttr()方法删除特定的属性，方法是在参数中指定属性名。&nbsp;</p><pre><code>$(''p'').attr(''title'');\n$(''p'').attr(''title'':''题目'');\n$(''p'').attr({''title'':''题目''，''name'':''水果''});</code></pre><p>(5)样式操作&nbsp;<br>addClass()、removeClass()这对儿方法是添加和删除样式。&nbsp;<br>toggleClass()该方法用来切换目标元素的样式。&nbsp;<br>(6)其他常见操作&nbsp;<br>第一句是获取值，第二句是设置值。&nbsp;</p><pre><code>$(''id'').val();\n$(''id'').val(''hello'')</code></pre><p>css操作&nbsp;<br>设置添加css样式&nbsp;</p><pre><code>$(''p'').css(''color'',''red'');</code></pre><p>按照惯例，列出一些可以参考的资料&nbsp;<br><a href="http://www.cnblogs.com/ini_always/archive/2011/11/09/2243671.html" target="_blank">http://www.cnblogs.com/ini_always/archive/2011/11/09/2243671.html</a>&nbsp;<br><a href="http://wenku.baidu.com/view/a6b9673783c4bb4cf7ecd119.html" target="_blank">http://wenku.baidu.com/view/a6b9673783c4bb4cf7ecd119.html</a>&nbsp;<br><a href="http://www.nowamagic.net/librarys/posts/jquery/5" target="_blank">http://www.nowamagic.net/librarys/posts/jquery/5</a>&nbsp;<br><a href="http://www.blogjava.net/DLevin/archive/2012/11/25/391933.html" target="_blank">http://www.blogjava.net/DLevin/archive/2012/11/25/391933.html</a>&nbsp;<br><a href="http://www.w3school.com.cn/htmldom/dom_nodes.asp" target="_blank">http://www.w3school.com.cn/htmldom/dom_nodes.asp</a>&nbsp;<br><a href="http://www.2cto.com/kf/201205/130535.html" target="_blank">http://www.2cto.com/kf/201205/130535.html</a>&nbsp;<br><a href="http://group.cnblogs.com/topic/39811.html" target="_blank">http://group.cnblogs.com/topic/39811.html</a>&nbsp;<br><a href="http://www.cnblogs.com/bro-ma/p/3063942.html" target="_blank">http://www.cnblogs.com/bro-ma/p/3063942.html</a>&nbsp;&nbsp;</p><p>&nbsp;<br></p>', '为什么会提到Dom树呢，或许它对于我们很好地理解网页各个元素，标签和控件搭配，以及各种js，css等的加载会有一些帮助。笔者在工程中遇到了一些小问题，本质就是dom树的东西掌握的不扎实。所以借此来梳理一下。 1.HTML DOM ok, 我们先来看一下W3school中怎么解释这个概念和结构的。W3school是一个很不错的网站，很适合初学者和基础不扎实的人。HTML DOM 定义了访问和操作 HTML 文档的标准方法。DOM 将 HTML 文档表达为树结构。 W3C 文档对象模型 （DOM） 是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。 W3C DOM 标准被分为 3 个不同的部分： 核心 DOM - 针对任何结构化文档的标准模型 XML DOM - 针对 XML 文档的标准模型 HTML DOM - 针对 HTML 文档的标准模型 我们主要来看HTML DOM HTML DOM 是： HTML 的标准对象模型 HTML 的标准编程接口 W3C 标准DOM 节点 根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点： 整个文档是一个文档节点 每个 HTML 元素是元素节点 HTML 元素内的文本是文本节点 每个 HTML 属性是属性节点 注释是注释节点 2.获取节点的原生方法3.JS中的节点操作 写几个常用的API, 来操作DOM节点。 (1)document.getElementById()这个是最基本的了。 (2)object.innerHTML该属性设置或返回object之间的HTML (3)document.createElement()创建节点对象。 (4)document.body.appendChild()尾部插入结点。 (5)object.parentNode.removeChild(oChildNode);移除结点4.jQuery中的结点操作 (1)添加结点 a. append()和appendTo(), 两个方法刚好是对应的一对儿操作。$(''#parentNodeId'').append(childNode);$(''#childeNode'').appendTo(parentNode);b. prepend()和prependTo()， 这也是一对儿对应的操作方法。其作用是添加一个结点到父节点中并前置。用法和上一对儿一样。c. 与之对应的还有after, insertAfter; before, insertBefore等，其用法都和上面的相同。其效果是将新建的元素插入到指定的元素之后/前，并和目标元素紧邻，作为兄弟结点存在。(2)删除结点 a. remove() remove()方法删除所有匹配的元素，传入的参数用于筛选元素，该方法可以删除元素中所有的子节点，当匹配的节点及后代被删除后，该方法返回值是指向被删除结点的引用，因此可以使用该引用，再使用被删除的元素。$span = $(''span'').remove();$span = $(''span'').remove();\n$span.insertAfter(''ul'');我们可以看到，该示例中，先删除所有的span元素，把删除的元素使用$span接收，把删除后的元素添加到ul后面，作为ul的兄弟结点。该操作产生的效果即把所有的span元素以及后代元素移到ul后面。 b. empty() empty()方法严格来讲并不是删除元素，该方法只是清空节点，它能清空元素中的所有子节点。(3)修改DOM节点 a. 复制节点，当clone()方法有参数，并且为true时，表示同时复制该元素的属性，如果没有参数，表示不复制属性。$(element).clone(true);b.替换节点 这两个方法都可以实现替换节点的问题。 $(element).replacewith();\n$(element).replaceAll();c.包裹节点 $(element).wrap()\n$(element).wrapAll()\n$(element).wraplnner()(4)属性操作 attr()和removeAttr()。 attr()方法能够获取元素属性，也能够设置元素属性。removeAttr()方法删除特定的属性，方法是在参数中指定属性名。 $(''p'').attr(''title'');\n$(''p'').attr(''title'':''题目'');\n$(''p'').attr({''title'':''题目''，''name'':''水果''});(5)样式操作 addClass()、removeClass()这对儿方法是添加和删除样式。 toggleClass()该方法用来切换目标元素的样式。 (6)其他常见操作 第一句是获取值，第二句是设置值。 $(''id'').val();\n$(''id'').val(''hello'')css操作 设置添加css样式 $(''p'').css(''color'',''red'');按照惯例，列出一些可以参考的资料 http://www.cnblogs.com/ini_always/archive/2011/11/09/2243671.html http://wenku.baidu.com/view/a6b9673783c4bb4cf7ecd119.html http://www.nowamagic.net/librarys/posts/jquery/5 http://www.blogjava.net/DLevin/archive/2012/11/25/391933.html http://www.w3school.com.cn/htmldom/dom_nodes.asp http://www.2cto.com/kf/201205/130535.html http://group.cnblogs.com/topic/39811.html http://www.cnblogs.com/bro-ma/p/3063942.html   ', 1, 0, 24, 6, 1, 1),
(24, '渲染树render tree', 'RachelChen（博客园）', '2017-11-08 12:31:07', '2017-11-04 15:01:54', '<p>CSSOM树和DOM树连接在一起形成一个render tree，渲染树用来计算可见元素的布局并且作为将像素渲染到屏幕上的过程的输入。</p><div><ul><li>DOM树和CSSOM树连接在一起形成render tree .</li><li>render tree只包含了用于渲染页面的节点</li><li>布局计算了每一个对象的准确的位置以及大小</li><li>绘画是最后一步，绘画要求利用render tree来将像素显示到屏幕上</li></ul></div><p>第一步是结合DOM树和CSSOM树形成“render tree”，渲染树用来描述所有可见的DOM内容，并且将CSSOM样式信息附加到节点上。</p><p><br></p><p>为了形成渲染树，浏览器大致做的事情有:</p><ol><li>从DOM树根节点开始，遍历每一个可见的节点<ul><li>一些节点是完全不可见的（比如 script标签，meta标签等），这些节点会被忽略，因为他们不会影响渲染的输出</li><li>一些节点是通过CSS样式隐藏了，这些节点同样被忽略——例如上例中的span节点在render tree中被忽略，因为span样式是display:none;</li></ul></li><li>对每一个可见的节点，找到合适的匹配的CSSOM规则，并且应用样式</li><li>显示可见节点（节点包括内容和被计算的样式）</li></ol><div><h3>记住</h3><ul><li>记住“visibility:hidden”和“display：none”之间的不同，“visibility:hidden”将元素设置为不可见，但是同样在布局上占领一定空间（例如，它会被渲染成为空盒子），但是“display:none”的元素是将节点从整个render tree中移除，所以不是布局中的一部分 。</li></ul></div><p>最后输出的是一个render包括了屏幕上可见内容的样式信息和内容信息。</p><p>我们知道了哪些元素应该被显示以及元素的样式，但是我们还没有计算元素在设备中的确切的位置和大小——这是“布局”阶段，同样也被叫做“reflow”。<span style="background-color: rgb(241, 241, 241); color: inherit; font-family: Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace; font-size: inherit; white-space: pre-wrap;">&lt;html&gt;</span></p><pre><code>  &lt;head&gt;\n    &lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt;\n    &lt;title&gt;Critial Path: Hello world!&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div style="width: 50%"&gt;\n      &lt;div style="width: 50%"&gt;Hello world!&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre><p>上面的页面展示了两个div：第一个div是整个视图的一半，第二个div是父亲宽度的一半——也就是说是整个视图的25%。布局的输出是“盒子模型”，并且将相对定位转化成屏幕上的绝对像素。</p><p>最后，我们只差将render tree上的所有节点转化成屏幕上的确切像素——这个步骤通常被称为“painting”或者“rasterizing”。</p><p>每个步骤都要花费一些时间，谷歌浏览器开封工具为我们描述了一些步骤所花费的时间：</p><p><br></p><ul><li>构造render tree和计算位置以及大小信息被捕捉在时间轴上的“Layout”时间中</li><li>一旦布局完成，浏览器计算"Paint Setup"和“Paint”事件用来描述render tree转化成屏幕上世纪像素的时间。</li></ul><p>显示构造render tree以及布局和paint的时间受到页面的大小，被应用的样式和正在运行的设备影响。</p><p>页面越大，浏览器将要做更多工作；样式越复杂，painting阶段所花费的时间也越多。</p><p>但是，我们的页面完成了！WOOOO！</p><p><br></p><p>让我们快速的浏览下浏览器所做的事情：</p><ol><li>处理HTML标签建立DOM树</li><li>处理CSS标签建立CSSOM树</li><li>连接CSSOM树和DOM树形成一个render树</li><li>在render树上运行布局来计算每个节点的形状</li><li>在屏幕上画每一个节点</li></ol><p>虽然我们的页面很简单，但是它进行了大量的工作！下一章我们讨论怎样对渲染进行优化。</p>', 'CSSOM树和DOM树连接在一起形成一个render tree，渲染树用来计算可见元素的布局并且作为将像素渲染到屏幕上的过程的输入。DOM树和CSSOM树连接在一起形成render tree .render tree只包含了用于渲染页面的节点布局计算了每一个对象的准确的位置以及大小绘画是最后一步，绘画要求利用render tree来将像素显示到屏幕上第一步是结合DOM树和CSSOM树形成“render tree”，渲染树用来描述所有可见的DOM内容，并且将CSSOM样式信息附加到节点上。为了形成渲染树，浏览器大致做的事情有:从DOM树根节点开始，遍历每一个可见的节点一些节点是完全不可见的（比如 script标签，meta标签等），这些节点会被忽略，因为他们不会影响渲染的输出一些节点是通过CSS样式隐藏了，这些节点同样被忽略——例如上例中的span节点在render tree中被忽略，因为span样式是display:none;对每一个可见的节点，找到合适的匹配的CSSOM规则，并且应用样式显示可见节点（节点包括内容和被计算的样式）记住记住“visibility:hidden”和“display：none”之间的不同，“visibility:hidden”将元素设置为不可见，但是同样在布局上占领一定空间（例如，它会被渲染成为空盒子），但是“display:none”的元素是将节点从整个render tree中移除，所以不是布局中的一部分 。最后输出的是一个render包括了屏幕上可见内容的样式信息和内容信息。我们知道了哪些元素应该被显示以及元素的样式，但是我们还没有计算元素在设备中的确切的位置和大小——这是“布局”阶段，同样也被叫做“reflow”。&lt;html&gt;  &lt;head&gt;\n    &lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt;\n    &lt;title&gt;Critial Path: Hello world!&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div style="width: 50%"&gt;\n      &lt;div style="width: 50%"&gt;Hello world!&lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;上面的页面展示了两个div：第一个div是整个视图的一半，第二个div是父亲宽度的一半——也就是说是整个视图的25%。布局的输出是“盒子模型”，并且将相对定位转化成屏幕上的绝对像素。最后，我们只差将render tree上的所有节点转化成屏幕上的确切像素——这个步骤通常被称为“painting”或者“rasterizing”。每个步骤都要花费一些时间，谷歌浏览器开封工具为我们描述了一些步骤所花费的时间：构造render tree和计算位置以及大小信息被捕捉在时间轴上的“Layout”时间中一旦布局完成，浏览器计算"Paint Setup"和“Paint”事件用来描述render tree转化成屏幕上世纪像素的时间。显示构造render tree以及布局和paint的时间受到页面的大小，被应用的样式和正在运行的设备影响。页面越大，浏览器将要做更多工作；样式越复杂，painting阶段所花费的时间也越多。但是，我们的页面完成了！WOOOO！让我们快速的浏览下浏览器所做的事情：处理HTML标签建立DOM树处理CSS标签建立CSSOM树连接CSSOM树和DOM树形成一个render树在render树上运行布局来计算每个节点的形状在屏幕上画每一个节点虽然我们的页面很简单，但是它进行了大量的工作！下一章我们讨论怎样对渲染进行优化。', 1, 0, 11, 7, 1, 1);
INSERT INTO `blog_article` VALUES
(25, '时间都用哪了', '一帘幽梦何寄', '2017-11-08 12:31:04', '2017-11-04 15:09:48', '<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;同事聊天，说到家长里短，一人问一男<a href="http://www.duwenzhang.com/huati/laoshi/index1.html">老师</a>，你家生气不？这位摸着脑袋，想了半天，才慢条斯理地说：“都挺忙的，生气？哪有<a href="http://www.duwenzhang.com/huati/shijian/index1.html">时间</a>啊”。他的话，把所有人都说乐了。</p><p>　　 “没时间生气”。真是绝妙好词。他告诉我们，生气，是要占用时间的。岂止生气，东拉西扯，玩游戏，斗地主，哪个不需要时间呢？若是把时间用在这上，是不是有点糟蹋了呢？</p><p>　　 我们平时过日子精打细算，可却从来没算过，把时间用来生气，对自己的身心有着多么巨大的损失； 我们平时省吃俭用，节省钱财，可却从没想过，节省<a href="http://www.duwenzhang.com/huati/wuliao/index1.html">无聊</a>的时间，用在有意义的事情上。做什么生意都会有赚有赔，只有一样生意只赔不赚， 那就是生别人的气，伤自己的身体，就是利用闲暇时间，生产八卦是非、无聊<a href="http://www.duwenzhang.com/huati/kongxu/index1.html">空虚</a>这个坏东西。</p><p>　　那么，把时间用在什么上能最值得呢？</p><p>　　首先，应把时间给<a href="http://www.duwenzhang.com/huati/fumu/index1.html">父母</a>。你有没有觉得，日渐衰老的父母，对儿女越来越<a href="http://www.duwenzhang.com/huati/yilai/index1.html">依赖</a>了？小时候，你是他们手中的宝，长大了，你是他们心中的<a href="http://www.duwenzhang.com/huati/yikao/index1.html">依靠</a>。所以，找点空闲，找点时间，领着<a href="http://www.duwenzhang.com/huati/haizi/index1.html">孩子</a>，常回家看看。也许，在外人眼里，你<a href="http://www.duwenzhang.com/huati/pingfan/index1.html">平凡</a>的如同一棵草，但在父母眼里，你就是阆苑仙葩，你就是美玉无暇，是他们心中无时无刻的<a href="http://www.duwenzhang.com/huati/qiangua/index1.html">牵挂</a>。下雪了，他们惦记你是不是挨冻，下雨了，他们担心你会不会挨浇，你回家的日子，就是他们的节日啊。所以，把时间给父母吧，因为，总有一天，他们会<a href="http://www.duwenzhang.com/huati/likai/index1.html">离开</a>我们，别给自己留下子欲养，亲不待的<a href="http://www.duwenzhang.com/huati/yihan/index1.html">遗憾</a>。</p><p>　　 把时间给孩子。孩子是我们的<a href="http://www.duwenzhang.com/huati/xiwang/index1.html">希望</a>，我们要陪着他们，跟他们一起<a href="http://www.duwenzhang.com/wenzhang/shenghuosuibi/chengzhang/">成长</a>。孩子的<a href="http://www.duwenzhang.com/huati/xinling/index1.html">心灵</a>是一张白纸，染上什么样的颜色，画出什么样的画图，取决于父母的正确教育和引导，不要说自己工作太忙，没有时间，不要只顾自己玩手机，看电视，把孩子晾在一边，不要把孩子甩给老人，或者放任不管，不要<a href="http://www.duwenzhang.com/huati/cuoguo/index1.html">错过</a>最佳教育时机，不要放过最佳教育事件，否则，等到坏<a href="http://www.duwenzhang.com/huati/xiguan/index1.html">习惯</a>已经养成，再纠正只会是事倍功半，甚至事得其反。有的孩子无视父母，对长辈没礼貌，脏话不离口，这大多是父母教育的失误。教育出一个好孩子，是他一生的顺利，是你一辈子的福气。</p><p>　　把时间给爱人。<a href="http://www.duwenzhang.com/huati/hunyin/index1.html">婚姻</a>是需要经营的。不要以为结了婚，就进入了爱的保险箱，要知道，<a href="http://www.duwenzhang.com/wenzhang/aiqingwenzhang/">爱情</a>是有保鲜期的。鲁迅说过，爱情要时时不断地更新，生长，创造。只有两人在精神上不断成长，才会给爱注入新的活力，新的动力，爱情才不会随着时光的流逝，悄悄流走。如果不交流，不沟通，你忙你的，我做我的，不交流，不沟通，做一对哑巴夫妻，爱情小河就会枯竭，干涸。还有什么<a href="http://www.duwenzhang.com/huati/xingfu/index1.html">幸福</a>可言呢？</p><p>　　把时间给<a href="http://www.duwenzhang.com/huati/pengyou/index1.html">朋友</a>。有句话说，财富不是一生的朋友，朋友却是一生的财富。闲暇时光，三两<a href="http://www.duwenzhang.com/huati/zhiji/index1.html">知己</a>，推心置腹，畅所欲言，无拘无束，<a href="http://www.duwenzhang.com/huati/kuaile/index1.html">快乐</a>一起分享，快乐成倍增长，<a href="http://www.duwenzhang.com/huati/tongku/index1.html">痛苦</a>一起分担，痛苦立刻减半，棘手的事情，让朋友出出主意，<a href="http://www.duwenzhang.com/huati/fannao/index1.html">烦恼</a>的事情，朋友给解解心宽，与朋友在一起，可海阔天空，云淡风轻，可家长里短，柴米油盐，那份惬意，无法比拟。正是，“有朋自远方来，不亦乐乎？”</p><p>　　 把时间给自己。平时为<a href="http://www.duwenzhang.com/wenzhang/shenghuosuibi/">生活</a>，忙忙碌碌，闲暇时间，也给自己放个假，为自己活一把。<a href="http://www.duwenzhang.com/huati/xihuan/index1.html">喜欢</a>旅游，抬脚就走吧，看看山，看看水，让心灵沐浴，回来定是一个全新的自己。喜欢逛街，就大街小巷商场串着走走，看到好衣服，不要总是犹豫，善待一回自己。喜欢看书，就在书海里畅游，从亚洲到非洲，从古代到现代，看美国如何为独立抗争，看中国睡狮如何猛醒怒吼。喜欢听音乐，就让悠扬美妙的音乐如清泉在石上奔流。瞬间让人如《梦系云水间》，如《走在云深不知处》……做自己喜欢做的事，是生活最大的<a href="http://www.duwenzhang.com/huati/xiangshou/index1.html">享受</a>。</p><p>　　 时间的脚步，从不停留，时间这产品，一次性消费，不会再有，此时用在这，就不能用在那。你用来生气，疾病就来找你；你用来欢乐，痛苦就销声匿迹。我们应该做一个聪明的时间设计师，高标准设计自己的生活，要用它来培养<a href="http://www.duwenzhang.com/wenzhang/qinqingwenzhang/">亲情</a>、<a href="http://www.duwenzhang.com/wenzhang/youqingwenzhang/">友情</a>和爱情，让<a href="http://www.duwenzhang.com/huati/zhenqing/index1.html">真情</a><a href="http://www.duwenzhang.com/huati/wennuan/index1.html">温暖</a>我们的<a href="http://www.duwenzhang.com/huati/shengming/index1.html">生命</a>，用它来锻炼身体，修炼心灵，修身养性，提高生活的品位。我们应该做一个精明的商家，让单位时间产生最大利润，不把时间浪费在根本不重要，根本没必要，或者根本就是赔本的事情上，比如怨愤，忧愁，烦恼，比如，无质量的闲聊，无意义的争执，无所谓的计较。</p><p>　　 黄金贵重，人们都知买，光阴无价，有钱也买不到它，可奇怪的是，有的人就是<a href="http://www.duwenzhang.com/huati/zhenxi/index1.html">珍惜</a>黄金，忽视光阴，有时还觉得光阴太多，觉得很廉价，竟然象对待乞丐一样，想打发。时间若是有知，该多么伤悲啊。</p><p>　　 门前老树长新芽，院里枯木又开花，时间都去哪了，一不小心就流走了。杨柳枯了，有再青的时候，桃花谢了，有再开的时候，时间走了，可没有再来的时候，“君不见，高堂明镜悲白发，朝如青丝暮成雪”，诗仙李白的感慨，人人都有吧，世上没有什么比时间更宝贵的，时间就是生命啊，聪明的你，可要好好利用它，让时间的土壤，生产的不是怨，而是恕，不是恨，而是爱，生产出人人喜爱的真善美来，如此 ，在有限的生命时段，我们才能活出生活的质量，活出生命的温度。</p>', '        同事聊天，说到家长里短，一人问一男老师，你家生气不？这位摸着脑袋，想了半天，才慢条斯理地说：“都挺忙的，生气？哪有时间啊”。他的话，把所有人都说乐了。　　 “没时间生气”。真是绝妙好词。他告诉我们，生气，是要占用时间的。岂止生气，东拉西扯，玩游戏，斗地主，哪个不需要时间呢？若是把时间用在这上，是不是有点糟蹋了呢？　　 我们平时过日子精打细算，可却从来没算过，把时间用来生气，对自己的身心有着多么巨大的损失； 我们平时省吃俭用，节省钱财，可却从没想过，节省无聊的时间，用在有意义的事情上。做什么生意都会有赚有赔，只有一样生意只赔不赚， 那就是生别人的气，伤自己的身体，就是利用闲暇时间，生产八卦是非、无聊空虚这个坏东西。　　那么，把时间用在什么上能最值得呢？　　首先，应把时间给父母。你有没有觉得，日渐衰老的父母，对儿女越来越依赖了？小时候，你是他们手中的宝，长大了，你是他们心中的依靠。所以，找点空闲，找点时间，领着孩子，常回家看看。也许，在外人眼里，你平凡的如同一棵草，但在父母眼里，你就是阆苑仙葩，你就是美玉无暇，是他们心中无时无刻的牵挂。下雪了，他们惦记你是不是挨冻，下雨了，他们担心你会不会挨浇，你回家的日子，就是他们的节日啊。所以，把时间给父母吧，因为，总有一天，他们会离开我们，别给自己留下子欲养，亲不待的遗憾。　　 把时间给孩子。孩子是我们的希望，我们要陪着他们，跟他们一起成长。孩子的心灵是一张白纸，染上什么样的颜色，画出什么样的画图，取决于父母的正确教育和引导，不要说自己工作太忙，没有时间，不要只顾自己玩手机，看电视，把孩子晾在一边，不要把孩子甩给老人，或者放任不管，不要错过最佳教育时机，不要放过最佳教育事件，否则，等到坏习惯已经养成，再纠正只会是事倍功半，甚至事得其反。有的孩子无视父母，对长辈没礼貌，脏话不离口，这大多是父母教育的失误。教育出一个好孩子，是他一生的顺利，是你一辈子的福气。　　把时间给爱人。婚姻是需要经营的。不要以为结了婚，就进入了爱的保险箱，要知道，爱情是有保鲜期的。鲁迅说过，爱情要时时不断地更新，生长，创造。只有两人在精神上不断成长，才会给爱注入新的活力，新的动力，爱情才不会随着时光的流逝，悄悄流走。如果不交流，不沟通，你忙你的，我做我的，不交流，不沟通，做一对哑巴夫妻，爱情小河就会枯竭，干涸。还有什么幸福可言呢？　　把时间给朋友。有句话说，财富不是一生的朋友，朋友却是一生的财富。闲暇时光，三两知己，推心置腹，畅所欲言，无拘无束，快乐一起分享，快乐成倍增长，痛苦一起分担，痛苦立刻减半，棘手的事情，让朋友出出主意，烦恼的事情，朋友给解解心宽，与朋友在一起，可海阔天空，云淡风轻，可家长里短，柴米油盐，那份惬意，无法比拟。正是，“有朋自远方来，不亦乐乎？”　　 把时间给自己。平时为生活，忙忙碌碌，闲暇时间，也给自己放个假，为自己活一把。喜欢旅游，抬脚就走吧，看看山，看看水，让心灵沐浴，回来定是一个全新的自己。喜欢逛街，就大街小巷商场串着走走，看到好衣服，不要总是犹豫，善待一回自己。喜欢看书，就在书海里畅游，从亚洲到非洲，从古代到现代，看美国如何为独立抗争，看中国睡狮如何猛醒怒吼。喜欢听音乐，就让悠扬美妙的音乐如清泉在石上奔流。瞬间让人如《梦系云水间》，如《走在云深不知处》……做自己喜欢做的事，是生活最大的享受。　　 时间的脚步，从不停留，时间这产品，一次性消费，不会再有，此时用在这，就不能用在那。你用来生气，疾病就来找你；你用来欢乐，痛苦就销声匿迹。我们应该做一个聪明的时间设计师，高标准设计自己的生活，要用它来培养亲情、友情和爱情，让真情温暖我们的生命，用它来锻炼身体，修炼心灵，修身养性，提高生活的品位。我们应该做一个精明的商家，让单位时间产生最大利润，不把时间浪费在根本不重要，根本没必要，或者根本就是赔本的事情上，比如怨愤，忧愁，烦恼，比如，无质量的闲聊，无意义的争执，无所谓的计较。　　 黄金贵重，人们都知买，光阴无价，有钱也买不到它，可奇怪的是，有的人就是珍惜黄金，忽视光阴，有时还觉得光阴太多，觉得很廉价，竟然象对待乞丐一样，想打发。时间若是有知，该多么伤悲啊。　　 门前老树长新芽，院里枯木又开花，时间都去哪了，一不小心就流走了。杨柳枯了，有再青的时候，桃花谢了，有再开的时候，时间走了，可没有再来的时候，“君不见，高堂明镜悲白发，朝如青丝暮成雪”，诗仙李白的感慨，人人都有吧，世上没有什么比时间更宝贵的，时间就是生命啊，聪明的你，可要好好利用它，让时间的土壤，生产的不是怨，而是恕，不是恨，而是爱，生产出人人喜爱的真善美来，如此 ，在有限的生命时段，我们才能活出生活的质量，活出生命的温度。', 2, 0, 8, 5, 1, 1),
(26, '珍惜幸福，莫负今朝', '管淑平', '2017-11-08 12:31:01', '2017-11-04 15:10:29', '<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;许多事情，大抵如此，当你<a href="http://www.duwenzhang.com/huati/yongyou/index1.html">拥有</a>的时候不知道它的弥足珍贵，而当你<a href="http://www.duwenzhang.com/huati/shiqu/index1.html">失去</a>了过后却又总是<a href="http://www.duwenzhang.com/huati/huaijiu/index1.html">怀念</a>不已。花有重开日，人无再少年。为人者一世，颇为短暂，能迎来今日，当万分<a href="http://www.duwenzhang.com/huati/zhizu/index1.html">知足</a>。过日子也是一样，当以平常心生情味，珍惜幸福，莫负今朝。</p><p>　　<a href="http://www.duwenzhang.com/wenzhang/renshengzheli/">人生</a>最大的<a href="http://www.duwenzhang.com/huati/kuaile/index1.html">快乐</a>不在于占有什么，而在于<a href="http://www.duwenzhang.com/huati/zhuiqiu/index1.html">追求</a>什么样的过程。</p><p>　　在我们的人生旅途中，总会有<a href="http://www.duwenzhang.com/huati/deshi/index1.html">得失</a>相伴，悲喜相依。而我们也终是在磕磕绊绊里独自<a href="http://www.duwenzhang.com/wenzhang/shenghuosuibi/chengzhang/">成长</a>，终是在风风雨雨里学会历练。四时有更替，季节有轮回，严冬过后暖春必到。常怀<a href="http://www.duwenzhang.com/huati/leguan/index1.html">乐观</a>之心，总能够发现光明所在，正如耐得住繁华见真淳，守得住云开见月明。幸福就在路上，只要我们有<a href="http://www.duwenzhang.com/huati/naixin/index1.html">耐心</a>，早晚有一天，我们也会发现。</p><p>　　弥尔顿说：“<a href="http://www.duwenzhang.com/huati/xinling/index1.html">心灵</a>建造了天国，也建造了地狱。”人之一生，背负的东西太多太多。荣华富贵，功<a href="http://www.duwenzhang.com/huati/mingli/index1.html">名利</a>禄，都是我们想要的，我们若一个也放不下，日久天长，追求的东西多了，我们早晚也会被压得喘不过气来。轻装前行，探索心灵，或许在旅途中我们就能轻轻松松地找寻到我们真正想要守护的东西。有的时候，我们身后拥有的东西多了，我们的思想也自然会跟着变得复杂。天堂和地狱的距离，有时仅是一念，洒脱的人自然放得开，踌躇的人总是被物欲烦着心。删繁就简，潇潇洒洒地活出自己的灿烂人生，在独一无二的人生轨迹里，我用诗意，用文字点缀着每一个<a href="http://www.duwenzhang.com/huati/pingfan/index1.html">平凡</a>而真实的日子，心中觉得已然足够，繁华过后，淡然自来，平凡的日子也是<a href="http://www.duwenzhang.com/huati/meihao/index1.html">美好</a>的。</p><p>　　乐观处世、张弛有度，<a href="http://www.duwenzhang.com/wenzhang/shenghuosuibi/">生活</a>自然充满情趣，有滋也有味。生活在这个世界上，你要为衣、食、住、行去奔忙，你要和各种各样的人打交道，你要应付各种各样的事情。<a href="http://www.duwenzhang.com/huati/cuozhe/index1.html">挫折</a>常有，苦难常有，面对充满变数的人生，我们唯一能做的，便是改变我们自己的<a href="http://www.duwenzhang.com/huati/xintai/index1.html">心态</a>，心有阳光，自然乐观有活力，心是<a href="http://www.duwenzhang.com/huati/wennuan/index1.html">温暖</a>的，又何惧千里冰封与万里雪飘？</p><p>　　泰戈尔曾说：“世界之路并没有铺满鲜花，每一步都有荆棘，但是你必须走过那条荆棘路，愉快，<a href="http://www.duwenzhang.com/huati/weixiao/index1.html">微笑</a>！”我们的人生，又何尝不需要这样的人生<a href="http://www.duwenzhang.com/huati/taidu/index1.html">态度</a>？一路上披荆斩棘，一路上却又总是磕磕绊绊，无风无雨不人生我是知道的，跨过沿途的千沟万壑，也终会迎来前方的康庄大道。心中有<a href="http://www.duwenzhang.com/huati/xiwang/index1.html">希望</a>，也自然会义无反顾地走下去，即使前方山高路太远，我仍然<a href="http://www.duwenzhang.com/huati/xiangxin/index1.html">相信</a>苦尽甜会来，相信雨后天自晴，到那时幸福也会不期而遇。</p><p>　　幸福就在路上，藏在每一个平凡的日子里。可惜人在年轻的时候，总是太<a href="http://www.duwenzhang.com/huati/zhizhuo/index1.html">执着</a>，追求了<a href="http://www.duwenzhang.com/huati/mubiao/index1.html">目标</a>，却又忽视了过程中的曼妙风景，在<a href="http://www.duwenzhang.com/huati/shijian/index1.html">时间</a>的流逝里颇为<a href="http://www.duwenzhang.com/huati/wunai/index1.html">无奈</a>和烦忧。其实，天下本无事，庸人自扰之。过分地追求结果的<a href="http://www.duwenzhang.com/huati/wanmei/index1.html">完美</a>，只会使得过程变得空洞而乏味，而结果也未必能如你所愿。人生自是有风云得失无常，而能够迎来今日的我们是多么的幸福。昨天已经过去，明天又尚未到来，只有今天是最为真实的。“水去日日流，花落知多少。万事立业在今日，莫待明朝悔今朝！”古语流传千古，是教训也是警醒。</p><p>　　若为草木，当欣欣以向荣；若为溪水，当涓涓而始流。人生在世，不如意者十之八九，<a href="http://www.duwenzhang.com/huati/neixin/index1.html">内心</a>常怀乐观，一切不愉之事也自然会迎刃而解。在内心修篱种菊，总比刻意避开车马喧嚣要更为宁静。结果无望，也不叹息，心有阳光，山河明媚，这一程山水，风景无穷，乐享过程，自得心安。</p><p>　　人生犹似一盘无解玲珑棋，与其苦苦思索无解的结局，倒不如好好<a href="http://www.duwenzhang.com/huati/xiangshou/index1.html">享受</a>这“下棋”中的快乐。虽深知人生如棋，一着不慎，全盘皆输。是的，人生如棋局，总是充满着变数，人生这场棋，有着太多的未知性，我们只能尽量地走好每一小步，在扑朔迷离中，找寻着希望和生机。或许前一秒你还处于山重水复疑无路的状态，转而后一秒自然而然就迎来柳暗花明又一村的境界，这便是人生棋局的魅力。话语里，本无多大玄机，只觉得，踏踏实实地经营人生，便已经是快乐无限了，不忧昨日，也不期明日，只是安静地<a href="http://www.duwenzhang.com/huati/chongshi/index1.html">充实</a>着今日，潇洒地过着最为真实的自己，已然幸福满满。</p><p>　　古希腊诗人荷马曾说过：“过去的事已经过去，过去的事无法弥补。”泰戈尔在《飞鸟集》中这样写道：“只管走过去，不要逗留着去采了花朵来保存，因为一路上，花朵也会继续开放的。”的确，昨日的阳光不再美，昨日的风雨不再大，昨日的光景也移不到今日的画册，不念过去，不畏将来，自己的人生终是自己做主，纵使是风雨阳光也要潇潇洒洒走一回。</p><p>　　每一天，凡来尘往，只道寻常。情未老，梦如旧，纵然生活很平凡，也要内心淡雅。柴米油盐酱醋茶的日子也会过得如琴棋书画诗酒花般典雅，只要你内心宁静安然，就连手中的锅碗瓢盆也能够碰撞出诗意的格调。每个人的生活都是五味杂陈的组合，正如咸有咸的妙，淡有淡的美，五味杂陈里，丰盈的终是自己最为纯粹的<a href="http://www.duwenzhang.com/huati/linghun/index1.html">灵魂</a>，丰盈的终是自己那颗热爱<a href="http://www.duwenzhang.com/huati/shengming/index1.html">生命</a>，热爱生活的心。以真心换来的幸福感受也是最为牢固的，就像患难之中才能见<a href="http://www.duwenzhang.com/huati/zhenqing/index1.html">真情</a>，用真心换来的幸福体验恰如涓涓流水，无声无息里滋润着柔婉的心灵。</p><p>　　“若生命是一朵花就应该自然地绽放，散发一缕芬芳于人间；若生命是一棵草就应该自然地生长，不因是一棵草而自悲自叹；若生命是一只蝶，何不翩翩起舞？”梁晓声笔下的生命皆有一份怡然自得、超然洒脱的情致。芸芸众生，既不是翻江倒海的蛟龙，也不是独霸一方的雄狮，我们在苦海里颠簸，我们在丛林里避险，平凡得好似海中的一滴水，好似林中的一片叶。而生命却不因平凡而卑微，人生百态，各有各的容颜，各有各的<a href="http://www.duwenzhang.com/huati/jiazhi/index1.html">价值</a>，纵使平凡，也要灿烂绽放！</p><p>　　不得不说时光总是太匆匆，伫立于<a href="http://www.duwenzhang.com/huati/huiyi/index1.html">回忆</a>的门槛，只能遥望，而我们却再也回不到最初的原点。没有什么过不去，只是再也回不去。季节是留不住的，是那飞花细雨的优柔；岁月是逃不掉的，是那难以忘却的扑朔与迷离。生活这一首绵长深远的诗歌，有过婉转，也有过曲折，人生的步履，有深有浅，岁月的痕迹，有过<a href="http://www.duwenzhang.com/huati/chenggong/index1.html">成功</a>也有过<a href="http://www.duwenzhang.com/huati/shibai/index1.html">失败</a>。经年后，再回首，一切都是美好如昔。</p><p>　　海子说：“面朝大海，春暖花开。”而我觉得不负今朝，自会幸福美好。不埋怨岁月苍老，不执迷爱恨情仇，也不贪恋功名利禄，任我两袖一挥，也能有清风明月，任我洒脱一笑，也能有无限山河。</p><p>　　归去来兮，尘埃落定，日子这般美好，而人最是安然，择一处净土，辟一方诗意，修身或是修心，写文或是听曲，也都是不错的选择。我只愿岁月静好，时光如旧，我只愿珍惜幸福美好，莫负今朝。</p><p>　　花有重开日，人无再少年，生活之美，藏匿于每一个平凡的日子，珍惜幸福，莫负今朝，你我需要用心对待。　　</p><p>　　<a href="http://www.duwenzhang.com/">文章</a>落笔于2017年08月21日</p><p>　　文章原创作者：管淑平</p>', '        许多事情，大抵如此，当你拥有的时候不知道它的弥足珍贵，而当你失去了过后却又总是怀念不已。花有重开日，人无再少年。为人者一世，颇为短暂，能迎来今日，当万分知足。过日子也是一样，当以平常心生情味，珍惜幸福，莫负今朝。　　人生最大的快乐不在于占有什么，而在于追求什么样的过程。　　在我们的人生旅途中，总会有得失相伴，悲喜相依。而我们也终是在磕磕绊绊里独自成长，终是在风风雨雨里学会历练。四时有更替，季节有轮回，严冬过后暖春必到。常怀乐观之心，总能够发现光明所在，正如耐得住繁华见真淳，守得住云开见月明。幸福就在路上，只要我们有耐心，早晚有一天，我们也会发现。　　弥尔顿说：“心灵建造了天国，也建造了地狱。”人之一生，背负的东西太多太多。荣华富贵，功名利禄，都是我们想要的，我们若一个也放不下，日久天长，追求的东西多了，我们早晚也会被压得喘不过气来。轻装前行，探索心灵，或许在旅途中我们就能轻轻松松地找寻到我们真正想要守护的东西。有的时候，我们身后拥有的东西多了，我们的思想也自然会跟着变得复杂。天堂和地狱的距离，有时仅是一念，洒脱的人自然放得开，踌躇的人总是被物欲烦着心。删繁就简，潇潇洒洒地活出自己的灿烂人生，在独一无二的人生轨迹里，我用诗意，用文字点缀着每一个平凡而真实的日子，心中觉得已然足够，繁华过后，淡然自来，平凡的日子也是美好的。　　乐观处世、张弛有度，生活自然充满情趣，有滋也有味。生活在这个世界上，你要为衣、食、住、行去奔忙，你要和各种各样的人打交道，你要应付各种各样的事情。挫折常有，苦难常有，面对充满变数的人生，我们唯一能做的，便是改变我们自己的心态，心有阳光，自然乐观有活力，心是温暖的，又何惧千里冰封与万里雪飘？　　泰戈尔曾说：“世界之路并没有铺满鲜花，每一步都有荆棘，但是你必须走过那条荆棘路，愉快，微笑！”我们的人生，又何尝不需要这样的人生态度？一路上披荆斩棘，一路上却又总是磕磕绊绊，无风无雨不人生我是知道的，跨过沿途的千沟万壑，也终会迎来前方的康庄大道。心中有希望，也自然会义无反顾地走下去，即使前方山高路太远，我仍然相信苦尽甜会来，相信雨后天自晴，到那时幸福也会不期而遇。　　幸福就在路上，藏在每一个平凡的日子里。可惜人在年轻的时候，总是太执着，追求了目标，却又忽视了过程中的曼妙风景，在时间的流逝里颇为无奈和烦忧。其实，天下本无事，庸人自扰之。过分地追求结果的完美，只会使得过程变得空洞而乏味，而结果也未必能如你所愿。人生自是有风云得失无常，而能够迎来今日的我们是多么的幸福。昨天已经过去，明天又尚未到来，只有今天是最为真实的。“水去日日流，花落知多少。万事立业在今日，莫待明朝悔今朝！”古语流传千古，是教训也是警醒。　　若为草木，当欣欣以向荣；若为溪水，当涓涓而始流。人生在世，不如意者十之八九，内心常怀乐观，一切不愉之事也自然会迎刃而解。在内心修篱种菊，总比刻意避开车马喧嚣要更为宁静。结果无望，也不叹息，心有阳光，山河明媚，这一程山水，风景无穷，乐享过程，自得心安。　　人生犹似一盘无解玲珑棋，与其苦苦思索无解的结局，倒不如好好享受这“下棋”中的快乐。虽深知人生如棋，一着不慎，全盘皆输。是的，人生如棋局，总是充满着变数，人生这场棋，有着太多的未知性，我们只能尽量地走好每一小步，在扑朔迷离中，找寻着希望和生机。或许前一秒你还处于山重水复疑无路的状态，转而后一秒自然而然就迎来柳暗花明又一村的境界，这便是人生棋局的魅力。话语里，本无多大玄机，只觉得，踏踏实实地经营人生，便已经是快乐无限了，不忧昨日，也不期明日，只是安静地充实着今日，潇洒地过着最为真实的自己，已然幸福满满。　　古希腊诗人荷马曾说过：“过去的事已经过去，过去的事无法弥补。”泰戈尔在《飞鸟集》中这样写道：“只管走过去，不要逗留着去采了花朵来保存，因为一路上，花朵也会继续开放的。”的确，昨日的阳光不再美，昨日的风雨不再大，昨日的光景也移不到今日的画册，不念过去，不畏将来，自己的人生终是自己做主，纵使是风雨阳光也要潇潇洒洒走一回。　　每一天，凡来尘往，只道寻常。情未老，梦如旧，纵然生活很平凡，也要内心淡雅。柴米油盐酱醋茶的日子也会过得如琴棋书画诗酒花般典雅，只要你内心宁静安然，就连手中的锅碗瓢盆也能够碰撞出诗意的格调。每个人的生活都是五味杂陈的组合，正如咸有咸的妙，淡有淡的美，五味杂陈里，丰盈的终是自己最为纯粹的灵魂，丰盈的终是自己那颗热爱生命，热爱生活的心。以真心换来的幸福感受也是最为牢固的，就像患难之中才能见真情，用真心换来的幸福体验恰如涓涓流水，无声无息里滋润着柔婉的心灵。　　“若生命是一朵花就应该自然地绽放，散发一缕芬芳于人间；若生命是一棵草就应该自然地生长，不因是一棵草而自悲自叹；若生命是一只蝶，何不翩翩起舞？”梁晓声笔下的生命皆有一份怡然自得、超然洒脱的情致。芸芸众生，既不是翻江倒海的蛟龙，也不是独霸一方的雄狮，我们在苦海里颠簸，我们在丛林里避险，平凡得好似海中的一滴水，好似林中的一片叶。而生命却不因平凡而卑微，人生百态，各有各的容颜，各有各的价值，纵使平凡，也要灿烂绽放！　　不得不说时光总是太匆匆，伫立于回忆的门槛，只能遥望，而我们却再也回不到最初的原点。没有什么过不去，只是再也回不去。季节是留不住的，是那飞花细雨的优柔；岁月是逃不掉的，是那难以忘却的扑朔与迷离。生活这一首绵长深远的诗歌，有过婉转，也有过曲折，人生的步履，有深有浅，岁月的痕迹，有过成功也有过失败。经年后，再回首，一切都是美好如昔。　　海子说：“面朝大海，春暖花开。”而我觉得不负今朝，自会幸福美好。不埋怨岁月苍老，不执迷爱恨情仇，也不贪恋功名利禄，任我两袖一挥，也能有清风明月，任我洒脱一笑，也能有无限山河。　　归去来兮，尘埃落定，日子这般美好，而人最是安然，择一处净土，辟一方诗意，修身或是修心，写文或是听曲，也都是不错的选择。我只愿岁月静好，时光如旧，我只愿珍惜幸福美好，莫负今朝。　　花有重开日，人无再少年，生活之美，藏匿于每一个平凡的日子，珍惜幸福，莫负今朝，你我需要用心对待。　　　　文章落笔于2017年08月21日　　文章原创作者：管淑平', 2, 0, 0, 5, 1, 1),
(27, '不是这世界不美好，只是我们还没有强大', 'yyyy0101', '2017-11-08 12:30:59', '2017-11-04 15:12:54', '<p>&nbsp; &nbsp; &nbsp; &nbsp;也许，在一个阳光明媚的日子里，你兴高采烈的郊游，看到那么绿的草，艳的花，心里很是愉悦，<a href="http://www.duwenzhang.com/huati/ganjue/index1.html">感觉</a>这世界尽是美的。</p><p>　　又有那么一天，也是一个好天气，可是因为前一次的事办砸了，<a href="http://www.duwenzhang.com/wenzhang/xinqingriji/">心情</a>很郁闷，你走在绿叶葱郁里，却感受不到清新，满眼尽是哀叹。</p><p>　　情由心生，景由心看，一样的美景，两种截然不同的感受，因为心情不一样。很多时候，外界并没有改变，改变的是我们的心境，内在的变化，导致以不同的视角来看待这个世界。</p><p>　　一般情况来讲，<a href="http://www.duwenzhang.com/huati/neixin/index1.html">内心</a>强大的人通常更能感受<a href="http://www.duwenzhang.com/wenzhang/shenghuosuibi/">生活</a>的<a href="http://www.duwenzhang.com/huati/meihao/index1.html">美好</a>。他们的强大来源于对自己的肯定<a href="http://www.duwenzhang.com/huati/zixin/index1.html">自信</a>，承认接受<a href="http://www.duwenzhang.com/huati/xianshi/index1.html">现实</a>，有强劲的<a href="http://www.duwenzhang.com/huati/shengming/index1.html">生命</a>活力。</p><p>　　小李是一个农村家里的<a href="http://www.duwenzhang.com/huati/haizi/index1.html">孩子</a>，自小<a href="http://www.duwenzhang.com/huati/jiating/index1.html">家庭</a>困难，兄妹三个，数他最聪明，<a href="http://www.duwenzhang.com/huati/fumu/index1.html">父母</a>下决心就是砸锅卖铁也要供他上<a href="http://www.duwenzhang.com/wenzhang/xiaoyuanwenzhang/daxueshenghuo/">大学</a>，他表现也一直很好。可是在高考的时候，可能太紧张，压力过大，没有发挥好。这样的情况，发生了三次，连续三次高考都没有考好。</p><p>　　但是第四次的时候，他暗暗改变了自己，不在抱过高的期望值，没考上照样可以打工赚钱，这样想后，他反而释然了，第四次高考终于考上了心仪的大学。现在的他是公务员，工作稳定，有房有车，娶了一个漂亮的<a href="http://www.duwenzhang.com/huati/laopo/index1.html">老婆</a>，还有一个<a href="http://www.duwenzhang.com/huati/keai/index1.html">可爱</a>的儿子。</p><p>　　这几年看到他时，总是笑眯眯的，露出<a href="http://www.duwenzhang.com/huati/xingfu/index1.html">幸福</a><a href="http://www.duwenzhang.com/huati/manzu/index1.html">满足</a>的<a href="http://www.duwenzhang.com/huati/weixiao/index1.html">微笑</a>，哪像以前，总是愁眉不展，压力山大的样子。</p><p>　　外界没有变，变的只是自己的<a href="http://www.duwenzhang.com/huati/xintai/index1.html">心态</a>，于是自己的生活也在悄悄发生变化，你看待外界的景所产生的感受也就不一样了。</p><p>　　每一次跌入谷底时，是认识自我的好机会，知道自己为什么不<a href="http://www.duwenzhang.com/huati/chenggong/index1.html">成功</a>，总结原因，寻找办法，为下一次的腾飞打下坚实的的基础。这就是强大的基础，想着自己会成功，你就会有源源不断的动力，为成功铺路。</p><p>　　前几年，我的一位<a href="http://www.duwenzhang.com/huati/pengyou/index1.html">朋友</a>高考失利后，在一个<a href="http://www.duwenzhang.com/huati/laoshi/index1.html">老师</a>傅那里学习木匠手艺。可是那位老师傅年纪观念比较传统，还是抱着“学手艺先干三年家务活”想法，老是让他做杂事，例如搞卫生做饭，不教他真本领，干了三个月后，朋友一气之下走了，进电子厂当了一名工人。</p><p>　　他从普工做起，经常加班，慢慢有了存款，放假的时候，不像别的工友那样吃喝逛街，而是买了一些电器维修的书看，还经常向厂里的老技工请教电子技术方面的问题。</p><p>　　就这样，过了两年，他有了自己打工的积蓄，也学到了技术，就回老家镇上开了一家电器维修店。五万多人的小镇，这样的维修店有五六家，可是因为他技术最好，又勤快，上门服务，就数他的生意最好，现在他在县城有两套房子，还有价格不菲的小车。</p><p>　　这位朋友当年是被父母寄予厚望的，因为高考的失利，被父母骂的狗血喷头，他自己自尊心也受到很大的<a href="http://www.duwenzhang.com/huati/shanghai/index1.html">伤害</a>。在学木匠道道时，老师傅没有一天给他好脸色，认为他将来是抢自己饭碗的人，所以一直没教真领，还让他干很重的杂活。</p><p>　　我们能体会，那段<a href="http://www.duwenzhang.com/huati/shijian/index1.html">时间</a>，他是非常压抑，没有前途，没有<a href="http://www.duwenzhang.com/huati/xiwang/index1.html">希望</a>，过的也不愉快，可是他并没有服输，而是在<a href="http://www.duwenzhang.com/huati/nuli/index1.html">努力</a>寻找希望，给自己机会，终于凭自己的努力收获了丰盈的<a href="http://www.duwenzhang.com/wenzhang/renshengzheli/">人生</a>。</p><p>　　小李和这位朋友都是生活的强者，他们永远会在黑暗中寻找希望的丝丝光亮，不断的给自己信心，寻找机会，迎来黎明的曙光。</p><p>　　有时，不是这世界不美好，只是我们还没有强大。</p>', '       也许，在一个阳光明媚的日子里，你兴高采烈的郊游，看到那么绿的草，艳的花，心里很是愉悦，感觉这世界尽是美的。　　又有那么一天，也是一个好天气，可是因为前一次的事办砸了，心情很郁闷，你走在绿叶葱郁里，却感受不到清新，满眼尽是哀叹。　　情由心生，景由心看，一样的美景，两种截然不同的感受，因为心情不一样。很多时候，外界并没有改变，改变的是我们的心境，内在的变化，导致以不同的视角来看待这个世界。　　一般情况来讲，内心强大的人通常更能感受生活的美好。他们的强大来源于对自己的肯定自信，承认接受现实，有强劲的生命活力。　　小李是一个农村家里的孩子，自小家庭困难，兄妹三个，数他最聪明，父母下决心就是砸锅卖铁也要供他上大学，他表现也一直很好。可是在高考的时候，可能太紧张，压力过大，没有发挥好。这样的情况，发生了三次，连续三次高考都没有考好。　　但是第四次的时候，他暗暗改变了自己，不在抱过高的期望值，没考上照样可以打工赚钱，这样想后，他反而释然了，第四次高考终于考上了心仪的大学。现在的他是公务员，工作稳定，有房有车，娶了一个漂亮的老婆，还有一个可爱的儿子。　　这几年看到他时，总是笑眯眯的，露出幸福满足的微笑，哪像以前，总是愁眉不展，压力山大的样子。　　外界没有变，变的只是自己的心态，于是自己的生活也在悄悄发生变化，你看待外界的景所产生的感受也就不一样了。　　每一次跌入谷底时，是认识自我的好机会，知道自己为什么不成功，总结原因，寻找办法，为下一次的腾飞打下坚实的的基础。这就是强大的基础，想着自己会成功，你就会有源源不断的动力，为成功铺路。　　前几年，我的一位朋友高考失利后，在一个老师傅那里学习木匠手艺。可是那位老师傅年纪观念比较传统，还是抱着“学手艺先干三年家务活”想法，老是让他做杂事，例如搞卫生做饭，不教他真本领，干了三个月后，朋友一气之下走了，进电子厂当了一名工人。　　他从普工做起，经常加班，慢慢有了存款，放假的时候，不像别的工友那样吃喝逛街，而是买了一些电器维修的书看，还经常向厂里的老技工请教电子技术方面的问题。　　就这样，过了两年，他有了自己打工的积蓄，也学到了技术，就回老家镇上开了一家电器维修店。五万多人的小镇，这样的维修店有五六家，可是因为他技术最好，又勤快，上门服务，就数他的生意最好，现在他在县城有两套房子，还有价格不菲的小车。　　这位朋友当年是被父母寄予厚望的，因为高考的失利，被父母骂的狗血喷头，他自己自尊心也受到很大的伤害。在学木匠道道时，老师傅没有一天给他好脸色，认为他将来是抢自己饭碗的人，所以一直没教真领，还让他干很重的杂活。　　我们能体会，那段时间，他是非常压抑，没有前途，没有希望，过的也不愉快，可是他并没有服输，而是在努力寻找希望，给自己机会，终于凭自己的努力收获了丰盈的人生。　　小李和这位朋友都是生活的强者，他们永远会在黑暗中寻找希望的丝丝光亮，不断的给自己信心，寻找机会，迎来黎明的曙光。　　有时，不是这世界不美好，只是我们还没有强大。', 3, 0, 0, 6, 1, 1),
(28, '经过一番磨砺,卵石才变得更加美丽光滑', 'Susy', '2017-11-08 12:30:56', '2017-11-04 15:13:37', '<p>&nbsp; &nbsp; &nbsp; 梯子的梯阶从来不是用来搁脚的，它只是让人们的脚放上一段<a href="http://www.duwenzhang.com/huati/shijian/index1.html">时间</a>，以便让别一只脚能够再往上登。</p><p>　　山路曲折盘旋，但毕竟朝着顶峰延伸。</p><p>　　只有登上山顶，才能看到那边的风光。</p><p>　　即使道路坎坷不平，车轮也要前进；即使江河波涛汹涌，船只也航行。</p><p>　　只有创造，才是真正的<a href="http://www.duwenzhang.com/huati/xiangshou/index1.html">享受</a>，只有拚搏，才是<a href="http://www.duwenzhang.com/huati/chongshi/index1.html">充实</a>的<a href="http://www.duwenzhang.com/wenzhang/shenghuosuibi/">生活</a>。</p><p>　　敢于向黑暗宣战的人，心里必须充满光明。</p><p>　　崇高的<a href="http://www.duwenzhang.com/huati/lixiang/index1.html">理想</a>就象生长在高山上的鲜花。如果要搞下它，勤奋才能是攀登的绳索。</p><p>　　自然界没有风风雨雨，大地就不会春华秋实。</p><p>　　勤奋是你<a href="http://www.duwenzhang.com/huati/shengming/index1.html">生命</a>的密码，能译出你一部壮丽的史诗。</p><p>　　忙于采集的蜜蜂，无暇在人前高谈阔论。</p><p>　　勇士搏出惊涛骇流而不沉沦，懦夫在风平浪静也会溺水。</p><p>　　不管多么险峻的高山，总是为不畏艰难的人留下一条攀登的路。</p><p>　　只要能收获<a href="http://www.duwenzhang.com/huati/tianmi/index1.html">甜蜜</a>，荆棘丛中也会有蜜蜂忙碌的身影。</p><p>　　生活可以是甜的，也可以是苦的，但不能是没味的。你可以胜利，也可以<a href="http://www.duwenzhang.com/huati/shibai/index1.html">失败</a>，但你不能屈服。九百九十九次落空了，还有一千次呢……</p><p>　　机会只对进取有为的人开放，庸人永远无法光顾。</p><p>　　只会在水泥地上走路的人，永远不会留下深深的脚印。</p><p>　　生命力的意义在于拚搏，因为世界本身就是一个竞技场。</p><p>　　海浪的品格，就是无数次被礁石击碎又无数闪地扑向礁石。</p><p>　　榕树因为扎根于深厚的土壤，生命的绿荫才会越长越茂盛。</p><p>　　骄傲，是断了引线的风筝，稍纵即逝;<a href="http://www.duwenzhang.com/huati/zibei/index1.html">自卑</a>，是剪了双翼的飞鸟，难上青天。这两者都是成才的大忌。</p><p>　　树苗如果因为怕痛而拒绝修剪，那就永远不会成材。</p><p>　　经过大海的一番磨砺，卵石才变得更加<a href="http://www.duwenzhang.com/huati/meili/index1.html">美丽</a>光滑。</p><p>　　如果把才华比作剑，那么勤奋就是磨刀石。</p><p>　　经受了火的洗礼泥巴也会有<a href="http://www.duwenzhang.com/huati/jianqiang/index1.html">坚强</a>的体魄。</p><p>　　萤火虫的光点虽然微弱，但亮着便是向黑暗挑战。</p><p>　　美丽的蓝图，落在懒汉手里，也不过是一页废纸。</p><p>　　一时的<a href="http://www.duwenzhang.com/huati/cuozhe/index1.html">挫折</a>往往可以通过不屈的搏击，变成学问及见识。</p><p>　　<a href="http://www.duwenzhang.com/huati/nuli/index1.html">努力</a>向上的开拓，才使弯曲的竹鞭化作了笔直的毛竹。</p><p>　　不去耕耘 ，不去播种，再肥的沃土也长不出庄稼，不去<a href="http://www.duwenzhang.com/huati/fendou/index1.html">奋斗</a>，不去创造，再美的<a href="http://www.duwenzhang.com/huati/qingchun/index1.html">青春</a>也结不出硕果。</p><p>　　再好的种子，不播种下去，也结不出丰硕的果实。</p><p>　　如果可恨的挫折使你尝到苦果，那么，奋起必将让你尝到<a href="http://www.duwenzhang.com/wenzhang/renshengzheli/">人生</a>的欢乐。</p><p>　　瀑布---为了奔向江河湖海，即使面临百丈深渊，仍然呼啸前行，决不退缩 对于勇士来说，贫病、困窘、责难、诽谤、冷嘲热讽……，一切压迫都是前进的动力。</p><p>　　一帆风顺，并不等于行驶的是一条平坦的航线。</p><p>　　在茫茫沙漠，唯有前进的脚步才是<a href="http://www.duwenzhang.com/huati/xiwang/index1.html">希望</a>的象征。</p>', '      梯子的梯阶从来不是用来搁脚的，它只是让人们的脚放上一段时间，以便让别一只脚能够再往上登。　　山路曲折盘旋，但毕竟朝着顶峰延伸。　　只有登上山顶，才能看到那边的风光。　　即使道路坎坷不平，车轮也要前进；即使江河波涛汹涌，船只也航行。　　只有创造，才是真正的享受，只有拚搏，才是充实的生活。　　敢于向黑暗宣战的人，心里必须充满光明。　　崇高的理想就象生长在高山上的鲜花。如果要搞下它，勤奋才能是攀登的绳索。　　自然界没有风风雨雨，大地就不会春华秋实。　　勤奋是你生命的密码，能译出你一部壮丽的史诗。　　忙于采集的蜜蜂，无暇在人前高谈阔论。　　勇士搏出惊涛骇流而不沉沦，懦夫在风平浪静也会溺水。　　不管多么险峻的高山，总是为不畏艰难的人留下一条攀登的路。　　只要能收获甜蜜，荆棘丛中也会有蜜蜂忙碌的身影。　　生活可以是甜的，也可以是苦的，但不能是没味的。你可以胜利，也可以失败，但你不能屈服。九百九十九次落空了，还有一千次呢……　　机会只对进取有为的人开放，庸人永远无法光顾。　　只会在水泥地上走路的人，永远不会留下深深的脚印。　　生命力的意义在于拚搏，因为世界本身就是一个竞技场。　　海浪的品格，就是无数次被礁石击碎又无数闪地扑向礁石。　　榕树因为扎根于深厚的土壤，生命的绿荫才会越长越茂盛。　　骄傲，是断了引线的风筝，稍纵即逝;自卑，是剪了双翼的飞鸟，难上青天。这两者都是成才的大忌。　　树苗如果因为怕痛而拒绝修剪，那就永远不会成材。　　经过大海的一番磨砺，卵石才变得更加美丽光滑。　　如果把才华比作剑，那么勤奋就是磨刀石。　　经受了火的洗礼泥巴也会有坚强的体魄。　　萤火虫的光点虽然微弱，但亮着便是向黑暗挑战。　　美丽的蓝图，落在懒汉手里，也不过是一页废纸。　　一时的挫折往往可以通过不屈的搏击，变成学问及见识。　　努力向上的开拓，才使弯曲的竹鞭化作了笔直的毛竹。　　不去耕耘 ，不去播种，再肥的沃土也长不出庄稼，不去奋斗，不去创造，再美的青春也结不出硕果。　　再好的种子，不播种下去，也结不出丰硕的果实。　　如果可恨的挫折使你尝到苦果，那么，奋起必将让你尝到人生的欢乐。　　瀑布---为了奔向江河湖海，即使面临百丈深渊，仍然呼啸前行，决不退缩 对于勇士来说，贫病、困窘、责难、诽谤、冷嘲热讽……，一切压迫都是前进的动力。　　一帆风顺，并不等于行驶的是一条平坦的航线。　　在茫茫沙漠，唯有前进的脚步才是希望的象征。', 2, 0, 0, 5, 1, 1),
(29, 'JavaScript匿名函数以及在循环中的匿名函数', '方老司', '2017-11-08 12:30:54', '2017-11-04 15:23:33', '<h2 id="articleHeader0">一 历史</h2><p>JavaScript其实是一门奇异的语言，TA的一大特性是没有块级作用域</p><pre><code>for(var i=0;i&lt;10;i++){\n\n}\nconsole.log(i)</code></pre><p>大家猜测下值是多少？<br>答案是 10， 虽然我们在一个块内申明了变量，但i却是在全范围内起作用的，所以就引入了匿名函数&nbsp;</p><pre><code>function(){\n   var i=0;\n   ...\n}</code></pre><p><strong>以函数的作用域来限定变量作用域</strong></p><h2 id="articleHeader1">二 立即执行匿名函数</h2><p>当然，还立即执行的匿名函数</p><pre><code>(function(){\n   do sth.....\n})()</code></pre><p>第一次看到感觉真tm古怪，还tm要这样写，太tm古怪了，我们可以这样看:<br>定义一个虚拟变量 var foo = function(){...}<br>然后foo要执行，所以就</p><pre><code>foo() = (function(){\n       do sth.....\n    })()\n</code></pre><p>好了，匿名函数就立即执行了</p><h2 id="articleHeader2">三 循环中的匿名函数</h2><p>大家看下面一段代码</p><pre><code>function foo(){\n    var arr = [];\n    for(var i =0;i&lt;5;i++){\n      arr[i] = function(){\n        //console.log(i) 来看看什么时候运行\n        return i;   //定义函数时i的值并没有初始化，指向函数外的i，因此，当匿名函数运行时，这个值就指向最大的i了\n   }\n  }\n  return arr;\n}\n\nvar a = foo();   //arr的赋值没有被执行\nfor (var i = 0; i&lt; 5 ;i++){\n  alert(a[i]());\n}</code></pre><p>有兴趣的不妨运行一下，答案是5个5，发生什么事了呢？<br>我们在对arr赋值的时候：</p><pre><code> arr[i] = function(){\n            return i;  \n       }</code></pre><p>函数里面的i是没有分配具体的值的，它指向了最外层的i，而运行时才会赋值，所以，它就是最大的5了，再看一个例子</p><pre><code>var arr = document.getElementsByTagName("p");\n            for(var i = 0; i &lt; arr.length;i++){\n                arr[i].onclick = function(){\n                    alert(i);\n                }\n            }</code></pre><p>这是一个DOM的onclick事件，当点击的时想能够弹出不同的i值，实际上是无法实现的，所以，必须使用匿名函数的立即执行来限定作用域</p><pre><code>var arr = document.getElementsByTagName("p");\n                for(var i = 0; i &lt; arr.length;i++){\n                    (function(j){\n                        arr[j].onclick = function(){\n                            alert(j);\n                        }\n                    })(i)\n                }\n                \n        \n</code></pre><h2 id="articleHeader3">四 循环中的异步函数</h2><p>这样一段代码</p><pre><code>for(var i=0;i&lt;n;i++){\n  ajax(i,function(....)) //这里是一个异步调用，还有request，http等\n}\n</code></pre><p>这里i会是最大值，为何呢？因为这是一个异步函数，而非同步立即返回的函数，此时由于js奇怪的单线程机制，会待同步全部结束后再运行异步的代码，所以i始终是最大值，那么要用什么方法解决呢？是的，加一个闭包。</p><p>这里留下一个问题，如果写成这样，你觉得可以么</p><pre><code>for(var i=0;i&lt;n;i++){\n  var j={a:i}\n  ajax(j.a,function(....))\n}\n</code></pre><p>总之，js真是一门奇异的语言</p>', '一 历史JavaScript其实是一门奇异的语言，TA的一大特性是没有块级作用域for(var i=0;i&lt;10;i++){\n\n}\nconsole.log(i)大家猜测下值是多少？答案是 10， 虽然我们在一个块内申明了变量，但i却是在全范围内起作用的，所以就引入了匿名函数 function(){\n   var i=0;\n   ...\n}以函数的作用域来限定变量作用域二 立即执行匿名函数当然，还立即执行的匿名函数(function(){\n   do sth.....\n})()第一次看到感觉真tm古怪，还tm要这样写，太tm古怪了，我们可以这样看:定义一个虚拟变量 var foo = function(){...}然后foo要执行，所以就foo() = (function(){\n       do sth.....\n    })()\n好了，匿名函数就立即执行了三 循环中的匿名函数大家看下面一段代码function foo(){\n    var arr = [];\n    for(var i =0;i&lt;5;i++){\n      arr[i] = function(){\n        //console.log(i) 来看看什么时候运行\n        return i;   //定义函数时i的值并没有初始化，指向函数外的i，因此，当匿名函数运行时，这个值就指向最大的i了\n   }\n  }\n  return arr;\n}\n\nvar a = foo();   //arr的赋值没有被执行\nfor (var i = 0; i&lt; 5 ;i++){\n  alert(a[i]());\n}有兴趣的不妨运行一下，答案是5个5，发生什么事了呢？我们在对arr赋值的时候： arr[i] = function(){\n            return i;  \n       }函数里面的i是没有分配具体的值的，它指向了最外层的i，而运行时才会赋值，所以，它就是最大的5了，再看一个例子var arr = document.getElementsByTagName("p");\n            for(var i = 0; i &lt; arr.length;i++){\n                arr[i].onclick = function(){\n                    alert(i);\n                }\n            }这是一个DOM的onclick事件，当点击的时想能够弹出不同的i值，实际上是无法实现的，所以，必须使用匿名函数的立即执行来限定作用域var arr = document.getElementsByTagName("p");\n                for(var i = 0; i &lt; arr.length;i++){\n                    (function(j){\n                        arr[j].onclick = function(){\n                            alert(j);\n                        }\n                    })(i)\n                }\n                \n        \n四 循环中的异步函数这样一段代码for(var i=0;i&lt;n;i++){\n  ajax(i,function(....)) //这里是一个异步调用，还有request，http等\n}\n这里i会是最大值，为何呢？因为这是一个异步函数，而非同步立即返回的函数，此时由于js奇怪的单线程机制，会待同步全部结束后再运行异步的代码，所以i始终是最大值，那么要用什么方法解决呢？是的，加一个闭包。这里留下一个问题，如果写成这样，你觉得可以么for(var i=0;i&lt;n;i++){\n  var j={a:i}\n  ajax(j.a,function(....))\n}\n总之，js真是一门奇异的语言', 1, 0, 0, 6, 1, 1);
INSERT INTO `blog_article` VALUES
(30, '当你在浏览器中输入 baidu.com 并且按下回车后发生了什么', 'Aceyclee', '2017-11-08 12:30:51', '2017-11-04 15:26:23', '<h2><b>目录</b></h2><ul><li>按下「g」键</li><li>回车键按下</li><li>产生中断（非 USB 键盘）</li><li>(Windows) 一个 WM_KEYDOWN 消息被发往应用程序</li><li>(Mac OS X) 一个 KeyDown NSEvent被发往应用程序</li><li>(GNU/Linux)Xorg 服务器监听键码值</li><li>解析 URL</li><li>输入的是 URL 还是搜索的关键字？</li><li>转换非 ASCII 的 Unicode 字符</li><li>检查 HSTS 列表</li><li>DNS 查询</li><li>ARP 过程</li><li>使用套接字</li><li>TLS 握手</li><li>HTTP 协议</li><li>HTTP 服务器请求处理</li><li>浏览器背后的故事</li><li>浏览器</li><li>HTML 解析</li><li>CSS 解析</li><li>页面渲染</li><li>GPU 渲染</li><li>Window Server</li><li>后期渲染与用户引发的处理</li></ul><h2><b>按下「g」键</b></h2><p>接下来的内容介绍了物理键盘和系统中断的工作原理，但是有一部分内容没有涉及。</p><p>当你按下「g」键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。你打算输入「<a href="http://link.zhihu.com/?target=http%3A//google.com" target="_blank" rel="nofollow noreferrer">http://google.com<i></i></a>」，因此给出的建议并不匹配。但是输入过程中仍然有大量的代码在后台运行，你的每一次按键都会使得给出的建议更加准确。甚至有可能在你输入之前，浏览器就将 「<a href="http://link.zhihu.com/?target=http%3A//google.com" target="_blank" rel="nofollow noreferrer">http://google.com<i></i></a>」建议给你。</p><h2><b>回车键按下</b></h2><p>为了从零开始，我们选择键盘上的回车键被按到最低处作为起点。在这个时刻，一个专用于回车键的电流回路被直接地或者通过电容器间接地闭合了，使得少量的电流进入了键盘的逻辑电路系统。</p><p>这个系统会扫描每个键的状态，对于按键开关的电位弹跳变化进行噪音消除 (debounce)，并将其转化为键盘码值。在这里，回车的码值是13。键盘控制器在得到码值之后，将其编码，用于之后的传输。现在这个传输过程几乎都是通过通用串行总线 (USB) 或者蓝牙 (Bluetooth) 来进行的，以前是通过 PS/2 或者 ADB 连接进行。</p><p><b>USB 键盘：</b></p><ul><li>键盘的 USB 元件通过计算机上的 USB 接口与 USB 控制器相连接，USB 接口中的第一号针为它提供了 5V 的电压</li><li>键码值存储在键盘内部电路一个叫做「endpoint」的寄存器内</li><li>USB 控制器大概每隔 10ms 便查询一次「endpoint」以得到存储的键码值数据，这个最短时间间隔由键盘提供</li><li>键值码值通过 USB 串行接口引擎被转换成一个或者多个遵循低层 USB 协议的 USB 数据包</li><li>这些数据包通过 D+ 针或者 D- 针（中间的两个针），以最高 1.5Mb/s 的速度从键盘传输至计算机。速度限制是因为人机交互设备总是被声明成「低速设备」（USB 2.0 compliance）</li><li>这个串行信号在计算机的 USB 控制器处被解码，然后被人机交互设备通用键盘驱动进行进一步解释。之后按键的码值被传输到操作系统的硬件抽象层</li></ul><p><b>虚拟键盘（触屏设备）：</b></p><ul><li>在现代电容屏上，当用户把手指放在屏幕上时，一小部分电流从传导层的静电域经过手指传导，形成了一个回路，使得屏幕上触控的那一点电压下降，屏幕控制器产生一个中断，报告这次「点击」的坐标</li><li>然后移动操作系统通知当前活跃的应用，有一个点击事件发生在它的某个 GUI 部件上了，现在这个部件是虚拟键盘的按钮</li><li>虚拟键盘引发一个软中断，返回给 OS 一个「按键按下」消息</li><li>这个消息又返回来向当前活跃的应用通知一个「按键按下」事件</li></ul><h2><b>产生中断（非 USB 键盘）</b></h2><p>键盘在它的中断请求线 (IRQ) 上发送信号，信号会被中断控制器映射到一个中断向量，实际上就是一个整型数 。CPU 使用中断描述符表 (IDT) 把中断向量映射到对应函数，这些函数被称为中断处理器，它们由操作系统内核提供。当一个中断到达时，CPU 根据 IDT 和中断向量索引到对应的中断处理器，然后操作系统内核出场了。</p><h2><b>(Windows) 一个 WM_KEYDOWN 消息被发往应用程序</b></h2><p>HID 把键盘按下的事件传送给 KBDHID.sys 驱动，把 HID 的信号转换成一个扫描码(Scancode)，这里回车的扫描码是 VK_RETURN(0x0d)。 KBDHID.sys 驱动和 KBDCLASS.sys（键盘类驱动，keyboard class driver）进行交互，这个驱动负责安全地处理所有键盘和小键盘的输入事件。之后它又去调用 Win32K.sys ，在这之前有可能把消息传递给安装的第三方键盘过滤器。这些都是发生在内核模式。</p><p>Win32K.sys 通过 GetForegroundWindow() API 函数找到当前哪个窗口是活跃的。这个 API 函数提供了当前浏览器的地址栏的句柄。Windows 系统的「message pump」机制调用 SendMessage (hWnd, WM_KEYDOWN, VK_RETURN, lParam) 函数， lParam 是一个用来指示这个按键的更多信息的掩码，这些信息包括按键重复次数（这里是 0），实际扫描码（可能依赖于OEM 厂商，不过通常不会是 VK_RETURN ），功能键（alt, shift, ctrl）是否被按下（在这里没有），以及一些其他状态。</p><p>Windows 的 SendMessage API 直接将消息添加到特定窗口句柄 hWnd 的消息队列中，之后赋给 hWnd 的主要消息处理函数 WindowProc 将会被调用，用于处理队列中的消息。</p><p>当前活跃的句柄 hWnd 实际上是一个edit control控件，这种情况下，WindowProc 有一个用于处理 WM_KEYDOWN 消息的处理器，这段代码会查看 SendMessage 传入的第三个参数 wParam ，因为这个参数是 VK_RETURN ，于是它知道用户按下了回车键。</p><h2><b>(Mac OS X) 一个 KeyDown NSEvent 被发往应用程序</b></h2><p>中断信号引发了 I/O Kit Kext 键盘驱动的中断处理事件，驱动把信号翻译成键码值，然后传给OS X 的 WindowServer 进程。然后， WindowServer 将这个事件通过 Mach 端口分发给合适的（活跃的，或者正在监听的）应用程序，这个信号会被放到应用程序的消息队列里。队列中的消息可以被拥有足够高权限的线程使用 mach_ipc_dispatch 函数读取到。这个过程通常是由 NSApplication 主事件循环产生并且处理的，通过 NSEventType 为 KeyDown 的 NSEvent 。</p><h2><b>(GNU/Linux)Xorg 服务器监听键码值</b></h2><p>当使用图形化的 X Server 时，X Server 会按照特定的规则把键码值再一次映射，映射成扫描码。当这个映射过程完成之后， X Server 把这个按键字符发送给窗口管理器（DWM，metacity, i3 等等），窗口管理器再把字符发送给当前窗口。当前窗口使用有关图形 API 把文字打印在输入框内。</p><h2><b>解析URL</b></h2><p>浏览器通过 URL 能够知道下面的信息：</p><ul><li>Protocol "http" 使用 HTTP 协议</li><li>Resource "/" 请求的资源是主页 (index)</li></ul><h2><b>输入的是 URL 还是搜索的关键字？</b></h2><p>当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL 会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。</p><h2><b>转换非 ASCII 的 Unicode 字符</b></h2><ul><li>浏览器检查输入是否含有不是 a-z， A-Z，0-9， - 或者 . 的字符</li><li>这里主机名是&nbsp;<a href="http://link.zhihu.com/?target=http%3A//google.com" target="_blank" rel="nofollow noreferrer">http://google.com<i></i></a>&nbsp;，所以没有非 ASCII 的字符；如果有的话，浏览器会对主机名部分使用&nbsp;<a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Punycode" target="_blank" rel="nofollow noreferrer">Punycode<i></i></a>&nbsp;编码</li></ul><h2><b>检查 HSTS 列表</b></h2><ul><li>浏览器检查自带的「预加载 HSTS（HTTP严格传输安全）」列表，这个列表里包含了那些请求浏览器只使用 HTTPS 进行连接的网站</li><li>如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用 HTTP 协议发送</li><li>注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户受到&nbsp;<a href="http://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/SSL_stripping" target="_blank" rel="nofollow noreferrer">downgrade attack<i></i></a>&nbsp;的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。</li></ul><h2><b>DNS 查询</b></h2><ul><li>浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome://net-internals/#dns）。</li><li>如果缓存中没有，就去调用 gethostbyname 库函数（操作系统不同函数也不同）进行查询。</li><li>gethostbyname 函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置<a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Hosts_%2528file%2529%23Location_in_the_file_system" target="_blank" rel="nofollow noreferrer">不同的操作系统有所不同<i></i></a></li><li>如果 gethostbyname 没有这个域名的缓存记录，也没有在 hosts 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。</li><li>查询本地 DNS 服务器</li><li>如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询</li><li>如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询</li></ul><h2><b>ARP 过程</b></h2><p>要想发送 ARP（地址解析协议）广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。</p><ul><li>首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC</li></ul><p>如果缓存没有命中：</p><ul><li>查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。</li><li>查询选择的网络接口的 MAC 地址</li><li>我们发送一个二层（&nbsp;<a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/OSI_model" target="_blank" rel="nofollow noreferrer">OSI 模型<i></i></a>&nbsp;中的数据链路层）ARP 请求：</li></ul><p>ARP Request:</p><div><pre><code>Sender MAC: interface:mac:address:here\nSender IP: interface.ip.goes.here\nTarget MAC: FF:FF:FF:FF:FF:FF (Broadcast)\nTarget IP: target.ip.goes.here\n</code></pre></div><p>根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：</p><p>直连：</p><ul><li>如果我们和路由器是直接连接的，路由器会返回一个 ARP Reply （见下面）。</li></ul><p>集线器：</p><ul><li>如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个 ARP Reply 。</li></ul><p>交换机：</p><ul><li>如果我们连接到了一个交换机，交换机会检查本地 CAM/MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。</li><li>如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 ARP 请求</li><li>如果路由器也“连接”在其中，它会返回一个 ARP Reply</li></ul><p>ARP Reply:</p><div><pre><code>Sender MAC: target:mac:address:here\nSender IP: target.ip.goes.here\nTarget MAC: interface:mac:address:here\nTarget IP: interface.ip.goes.here\n</code></pre></div><p>现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了：</p><ul><li>使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议</li><li>如果本地 /ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回</li></ul><h2><b>使用套接字</b></h2><p>当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数 socket ，请求一个 TCP 流套接字，对应的参数是 AF_INET/AF_INET6 和 SOCK_STREAM 。</p><ul><li>这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是 ip_local_port_range）</li><li>TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的 IP 地址以及本机的 IP 地址，把它封装成一个TCP packet。</li><li>这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame 头部，里面包含了本地内置网卡的 MAC 地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。</li></ul><p>到了现在，TCP 封包已经准备好了，可以使用下面的方式进行传输：</p><ul><li><a href="http://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/IEEE_802.3" target="_blank" rel="nofollow noreferrer">以太网<i></i></a></li><li><a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/IEEE_802.11" target="_blank" rel="nofollow noreferrer">WiFi<i></i></a></li><li><a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Cellular_data_communication_protocol" target="_blank" rel="nofollow noreferrer">蜂窝数据网络<i></i></a></li></ul><p>对于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适于在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个<a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Computer_network%23Network_nodes" target="_blank" rel="nofollow noreferrer">网络节点<i></i></a>处理。节点的目标地址和源地址将在后面讨论。</p><p>大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个<a href="http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Computer_network%23Network_nodes" target="_blank" rel="nofollow noreferrer">网络节点<i></i></a>进行处理。</p><p>最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域（autonomous system, 缩写 AS）的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP 数据报头部 time to live (TTL) 域的值每经过一个路由器就减 1，如果封包的 TTL 变为 0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。</p><p>上面的发送和接受过程在 TCP 连接期间会发生很多次：</p><ul><li>客户端选择一个初始序列号 (ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号</li><li>服务器端接收到 SYN 包，如果它可以建立连接：</li><ul><li>服务器端选择它自己的初始序列号</li><li>服务器端设置 SYN 位，表明自己选择了一个初始序列号</li><li>服务器端把（客户端ISN + 1）复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个封包</li></ul><li>客户端通过发送下面一个封包来确认这次连接：</li><ul><li>自己的序列号+1</li><li>接收端 ACK+1</li><li>设置 ACK 位</li></ul><li>数据通过下面的方式传输：</li><ul><li>当一方发送了N个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N</li><li>另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号</li></ul><li>关闭连接时：</li><ul><li>要关闭连接的一方发送一个 FIN 包</li><li>另一方确认这个 FIN 包，并且发送自己的 FIN 包</li><li>要关闭的一方使用 ACK 包来确认接收到了 FIN</li></ul></ul><h2><b>TLS 握手</b></h2><ul><li>客户端发送一个 ClientHello 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。</li><li>服务器端向客户端返回一个 ServerHello 消息，消息中包含了服务器端的 TLS 版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥</li><li>客户端根据自己的信任 CA 列表，验证服务器端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥</li><li>服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥</li><li>客户端发送一个 Finished 消息给服务器端，使用对称密钥加密这次通讯的一个散列值</li><li>服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 Finished 消息，也使用协商好的对称密钥加密</li><li>从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容</li></ul><h2><b>HTTP 协议</b></h2><p>如果浏览器是 Google 出品的，它不会使用 HTTP 协议来获取页面信息，而是会与服务器端发送请求，商讨使用 SPDY 协议。</p><p>如果浏览器使用 HTTP 协议而不支持 SPDY 协议，它会向服务器发送这样的一个请求:</p><div><pre><code>GET / HTTP/1.1\nHost: google.com\nConnection: close\n[other headers]\n</code></pre></div><p>[other headers] 包含了一系列的由冒号分割开的键值对，它们的格式符合 HTTP 协议标准，它们之间由一个换行符分割开来。（这里我们假设浏览器没有违反 HTTP 协议标准的 bug，同时假设浏览器使用 HTTP/1.1 协议，不然的话头部可能不包含 Host 字段，同时 GET 请求中的版本号会变成 HTTP/1.0 或者 HTTP/0.9 。）</p><p>HTTP/1.1 定义了「关闭连接」的选项「close」，发送者使用这个选项指示这次连接在响应结束之后会断开。例如：</p><blockquote>Connection:close</blockquote><p>不支持持久连接的 HTTP/1.1 应用必须在每条消息中都包含「close」选项。</p><p>在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。</p><p>服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的:</p><div><pre><code>200 OK\n[response headers]\n</code></pre></div><p>然后是一个换行，接下来有效载荷 (payload)，也就是&nbsp;<a href="http://link.zhihu.com/?target=http%3A//www.google.com" target="_blank" rel="nofollow noreferrer">http://www.google.com<i></i></a>&nbsp;的 HTML 内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供之后的请求重用。</p><p>如果浏览器发送的 HTTP 头部包含了足够多的信息（例如包含了 Etag 头部），以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应:</p><div><pre><code>304 Not Modified\n[response headers]\n</code></pre></div><p>这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容。</p><p>在解析完 HTML 之后，浏览器和客户端会重复上面的过程，直到 HTML 页面引入的所有资源（图片，CSS，favicon.ico 等等）全部都获取完毕，区别只是头部的 GET / HTTP/1.1 会变成 GET /$(相对<a href="http://link.zhihu.com/?target=http%3A//www.google.com" target="_blank" rel="nofollow noreferrer">http://www.google.com<i></i></a>的URL) HTTP/1.1 。</p><p>如果 HTML 引入了&nbsp;<a href="http://link.zhihu.com/?target=http%3A//www.google.com" target="_blank" rel="nofollow noreferrer">http://www.google.com<i></i></a>&nbsp;域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 Host 头部会变成另外的域名。</p><h2><b>HTTP 服务器请求处理</b></h2><p>HTTPD(HTTP Daemon) 在服务器端处理请求 / 响应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。</p><ul><li>HTTPD 接收请求</li><li>服务器把请求拆分为以下几个参数：</li><ul><li>HTTP 请求方法（GET, POST, HEAD, PUT, DELETE, CONNECT, OPTIONS, 或者 TRACE）。直接在地址栏中输入 URL 这种情况下，使用的是 GET 方法</li><li>域名：<a href="http://link.zhihu.com/?target=http%3A//google.com" target="_blank" rel="nofollow noreferrer">http://google.com<i></i></a></li><li>请求路径/页面：/ (我们没有请求<a href="http://link.zhihu.com/?target=http%3A//google.com" target="_blank" rel="nofollow noreferrer">http://google.com<i></i></a>下的指定的页面，因此 / 是默认的路径)</li></ul><li>服务器验证其上已经配置了&nbsp;<a href="http://link.zhihu.com/?target=http%3A//google.com" target="_blank" rel="nofollow noreferrer">http://google.com<i></i></a>&nbsp;的虚拟主机</li><li>服务器验证&nbsp;<a href="http://link.zhihu.com/?target=http%3A//google.com" target="_blank" rel="nofollow noreferrer">http://google.com<i></i></a>&nbsp;接受 GET 方法</li><li>服务器验证该用户可以使用 GET 方法（根据 IP 地址，身份信息等）</li><li>如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求</li><li>服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是「/」，会访问首页文件（你可以重写这个规则，但是这个是最常用的）。</li><li>服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者</li></ul><h2><b>浏览器背后的故事</b></h2><p>当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：</p><ul><li>解析 —— HTML，CSS，JS</li><li>渲染 —— 构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制</li></ul><h2><b>浏览器</b></h2><p>浏览器的功能是从服务器上取回你想要的资源，然后展示在浏览器窗口当中。资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。资源的位置通过用户提供的 URI (Uniform Resource Identifier) 来确定。</p><p>浏览器解释和展示 HTML 文件的方法，在 HTML 和 CSS 的标准中有详细介绍。这些标准由 Web 标准组织 W3C (World Wide Web Consortium) 维护。</p><p>不同浏览器的用户界面大都十分接近，有很多共同的 UI 元素：</p><ul><li>一个地址栏</li><li>后退和前进按钮</li><li>书签选项</li><li>刷新和停止按钮</li><li>主页按钮</li></ul><p><b>浏览器高层架构</b></p><p>组成浏览器的组件有：</p><ul><li><b>用户界面</b>&nbsp;用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分</li><li><b>浏览器引擎</b>&nbsp;浏览器引擎负责让 UI 和渲染引擎协调工作</li><li><b>渲染引擎</b>&nbsp;渲染引擎负责展示请求内容。如果请求的内容是 HTML，渲染引擎会解析 HTML 和 CSS，然后将内容展示在屏幕上</li><li><b>网络组件</b>&nbsp;网络组件负责网络调用，例如 HTTP 请求等，使用一个平台无关接口，下层是针对不同平台的具体实现</li><li><b>UI后端</b>&nbsp;UI 后端用于绘制基本 UI 组件，例如下拉列表框和窗口。UI 后端暴露一个统一的平台无关的接口，下层使用操作系统的 UI 方法实现</li><li><b>Javascript 引擎</b>&nbsp;Javascript 引擎用于解析和执行 Javascript 代码</li><li><b>数据存储</b>&nbsp;数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如 Cookie 等。浏览器也需要支持诸如 localStorage，IndexedDB，WebSQL 和 FileSystem 之类的存储机制</li></ul><h2><b>HTML 解析</b></h2><p>浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成 8kB 大小的分块传输。</p><p>HTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。</p><p>解析树是以 DOM 元素以及属性为节点的树。DOM 是文档对象模型 (Document Object Model)的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部（如 JavaScript）的接口。树的根部是「Document」对象。整个 DOM 和 HTML 文档几乎是一对一的关系。</p><p><b>解析算法</b></p><p>HTML 不能使用常见的自顶向下或自底向上方法来进行分析。主要原因有以下几点:</p><ul><li>语言本身的「宽容」特性</li><li>HTML 本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们</li><li>解析过程需要反复。对于其他语言来说，源码不会在解析过程中发生变化，但是对于 HTML 来说，动态代码，例如脚本元素中包含的 document.write() 方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容</li></ul><p>由于不能使用常用的解析技术，浏览器创造了专门用于解析 HTML 的解析器。解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。</p><p><b>解析结束之后</b></p><p>浏览器开始加载网页的外部资源（CSS，图像，Javascript 文件等）。</p><p>此时浏览器把文档标记为可交互的（interactive），浏览器开始解析处于「推迟（deferred）」模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为「完成（complete）」，浏览器会触发「加载（load）」事件。</p><p>注意解析 HTML 网页时永远不会出现「无效语法（Invalid Syntax）」错误，浏览器会修复所有错误内容，然后继续解析。</p><h2><b>CSS 解析</b></h2><ul><li>根据&nbsp;<a href="http://link.zhihu.com/?target=http%3A//www.w3.org/TR/CSS2/grammar.html" target="_blank" rel="nofollow noreferrer">CSS词法和句法<i></i></a>&nbsp;分析 CSS 文件和 &lt;style&gt; 标签包含的内容以及 style 属性的值</li><li>每个 CSS 文件都被解析成一个样式表对象（StyleSheet object），这个对象里包含了带有选择器的 CSS 规则，和对应 CSS 语法的对象</li><li>CSS 解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器</li></ul><h2><b>页面渲染</b></h2><ul><li>通过遍历 DOM 节点树创建一个「Frame 树」或「渲染树」，并计算每个节点的各个 CSS 样式值</li><li>通过累加子节点的宽度，该节点的水平内边距 (padding)、边框 (border) 和外边距(margin)，自底向上的计算「Frame 树」中每个节点的首选 (preferred) 宽度</li><li>通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度</li><li>通过应用文字折行、累加子节点的高度和此节点的内边距 (padding)、边框 (border) 和外边距 (margin)，自底向上的计算每个节点的高度</li><li>使用上面的计算结果构建每个节点的坐标</li><li>当存在元素使用 floated，位置有 absolutely 或 relatively 属性的时候，会有更多复杂的计算，详见&nbsp;<a href="http://link.zhihu.com/?target=http%3A//dev.w3.org/csswg/css2/" target="_blank" rel="nofollow noreferrer">http://dev.w3.org/csswg/css2/<i></i></a>&nbsp;和&nbsp;<a href="http://link.zhihu.com/?target=http%3A//www.w3.org/Style/CSS/current-work" target="_blank" rel="nofollow noreferrer">http://www.w3.org/Style/CSS/current-work<i></i></a></li><li>创建 layer (层) 来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层</li><li>页面上的每个层都被分配了纹理</li><li>每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由 CPU 执行栅格化处理，或者直接通过 D2D / SkiaGL 在 GPU 上绘制</li><li>上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量</li><li>计算出各个层的最终位置，一组命令由 Direct3D/OpenGL 发出，GPU 命令缓冲区清空，命令传至 GPU 并异步渲染，帧被送到 Window Server。</li></ul><h2><b>GPU 渲染</b></h2><ul><li>在渲染过程中，图形处理层可能使用通用用途的 CPU，也可能使用图形处理器 GPU</li><li>当使用 GPU 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 GPU 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。</li></ul><h2><b>Window Server</b></h2><h2><b>后期渲染与用户引发的处理</b></h2><p>渲染结束后，浏览器根据某些时间机制运行 JavaScript 代码（比如 Google Doodle 动画）或与用户交互（在搜索栏输入关键字获得搜索建议）。类似 Flash 和 Java 的插件也会运行，尽管 Google 主页里没有。这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制。</p>', '目录按下「g」键回车键按下产生中断（非 USB 键盘）(Windows) 一个 WM_KEYDOWN 消息被发往应用程序(Mac OS X) 一个 KeyDown NSEvent被发往应用程序(GNU/Linux)Xorg 服务器监听键码值解析 URL输入的是 URL 还是搜索的关键字？转换非 ASCII 的 Unicode 字符检查 HSTS 列表DNS 查询ARP 过程使用套接字TLS 握手HTTP 协议HTTP 服务器请求处理浏览器背后的故事浏览器HTML 解析CSS 解析页面渲染GPU 渲染Window Server后期渲染与用户引发的处理按下「g」键接下来的内容介绍了物理键盘和系统中断的工作原理，但是有一部分内容没有涉及。当你按下「g」键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。你打算输入「http://google.com」，因此给出的建议并不匹配。但是输入过程中仍然有大量的代码在后台运行，你的每一次按键都会使得给出的建议更加准确。甚至有可能在你输入之前，浏览器就将 「http://google.com」建议给你。回车键按下为了从零开始，我们选择键盘上的回车键被按到最低处作为起点。在这个时刻，一个专用于回车键的电流回路被直接地或者通过电容器间接地闭合了，使得少量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的电位弹跳变化进行噪音消除 (debounce)，并将其转化为键盘码值。在这里，回车的码值是13。键盘控制器在得到码值之后，将其编码，用于之后的传输。现在这个传输过程几乎都是通过通用串行总线 (USB) 或者蓝牙 (Bluetooth) 来进行的，以前是通过 PS/2 或者 ADB 连接进行。USB 键盘：键盘的 USB 元件通过计算机上的 USB 接口与 USB 控制器相连接，USB 接口中的第一号针为它提供了 5V 的电压键码值存储在键盘内部电路一个叫做「endpoint」的寄存器内USB 控制器大概每隔 10ms 便查询一次「endpoint」以得到存储的键码值数据，这个最短时间间隔由键盘提供键值码值通过 USB 串行接口引擎被转换成一个或者多个遵循低层 USB 协议的 USB 数据包这些数据包通过 D+ 针或者 D- 针（中间的两个针），以最高 1.5Mb/s 的速度从键盘传输至计算机。速度限制是因为人机交互设备总是被声明成「低速设备」（USB 2.0 compliance）这个串行信号在计算机的 USB 控制器处被解码，然后被人机交互设备通用键盘驱动进行进一步解释。之后按键的码值被传输到操作系统的硬件抽象层虚拟键盘（触屏设备）：在现代电容屏上，当用户把手指放在屏幕上时，一小部分电流从传导层的静电域经过手指传导，形成了一个回路，使得屏幕上触控的那一点电压下降，屏幕控制器产生一个中断，报告这次「点击」的坐标然后移动操作系统通知当前活跃的应用，有一个点击事件发生在它的某个 GUI 部件上了，现在这个部件是虚拟键盘的按钮虚拟键盘引发一个软中断，返回给 OS 一个「按键按下」消息这个消息又返回来向当前活跃的应用通知一个「按键按下」事件产生中断（非 USB 键盘）键盘在它的中断请求线 (IRQ) 上发送信号，信号会被中断控制器映射到一个中断向量，实际上就是一个整型数 。CPU 使用中断描述符表 (IDT) 把中断向量映射到对应函数，这些函数被称为中断处理器，它们由操作系统内核提供。当一个中断到达时，CPU 根据 IDT 和中断向量索引到对应的中断处理器，然后操作系统内核出场了。(Windows) 一个 WM_KEYDOWN 消息被发往应用程序HID 把键盘按下的事件传送给 KBDHID.sys 驱动，把 HID 的信号转换成一个扫描码(Scancode)，这里回车的扫描码是 VK_RETURN(0x0d)。 KBDHID.sys 驱动和 KBDCLASS.sys（键盘类驱动，keyboard class driver）进行交互，这个驱动负责安全地处理所有键盘和小键盘的输入事件。之后它又去调用 Win32K.sys ，在这之前有可能把消息传递给安装的第三方键盘过滤器。这些都是发生在内核模式。Win32K.sys 通过 GetForegroundWindow() API 函数找到当前哪个窗口是活跃的。这个 API 函数提供了当前浏览器的地址栏的句柄。Windows 系统的「message pump」机制调用 SendMessage (hWnd, WM_KEYDOWN, VK_RETURN, lParam) 函数， lParam 是一个用来指示这个按键的更多信息的掩码，这些信息包括按键重复次数（这里是 0），实际扫描码（可能依赖于OEM 厂商，不过通常不会是 VK_RETURN ），功能键（alt, shift, ctrl）是否被按下（在这里没有），以及一些其他状态。Windows 的 SendMessage API 直接将消息添加到特定窗口句柄 hWnd 的消息队列中，之后赋给 hWnd 的主要消息处理函数 WindowProc 将会被调用，用于处理队列中的消息。当前活跃的句柄 hWnd 实际上是一个edit control控件，这种情况下，WindowProc 有一个用于处理 WM_KEYDOWN 消息的处理器，这段代码会查看 SendMessage 传入的第三个参数 wParam ，因为这个参数是 VK_RETURN ，于是它知道用户按下了回车键。(Mac OS X) 一个 KeyDown NSEvent 被发往应用程序中断信号引发了 I/O Kit Kext 键盘驱动的中断处理事件，驱动把信号翻译成键码值，然后传给OS X 的 WindowServer 进程。然后， WindowServer 将这个事件通过 Mach 端口分发给合适的（活跃的，或者正在监听的）应用程序，这个信号会被放到应用程序的消息队列里。队列中的消息可以被拥有足够高权限的线程使用 mach_ipc_dispatch 函数读取到。这个过程通常是由 NSApplication 主事件循环产生并且处理的，通过 NSEventType 为 KeyDown 的 NSEvent 。(GNU/Linux)Xorg 服务器监听键码值当使用图形化的 X Server 时，X Server 会按照特定的规则把键码值再一次映射，映射成扫描码。当这个映射过程完成之后， X Server 把这个按键字符发送给窗口管理器（DWM，metacity, i3 等等），窗口管理器再把字符发送给当前窗口。当前窗口使用有关图形 API 把文字打印在输入框内。解析URL浏览器通过 URL 能够知道下面的信息：Protocol "http" 使用 HTTP 协议Resource "/" 请求的资源是主页 (index)输入的是 URL 还是搜索的关键字？当协议或主机名不合法时，浏览器会将地址栏中输入的文字传给默认的搜索引擎。大部分情况下，在把文字传递给搜索引擎的时候，URL 会带有特定的一串字符，用来告诉搜索引擎这次搜索来自这个特定浏览器。转换非 ASCII 的 Unicode 字符浏览器检查输入是否含有不是 a-z， A-Z，0-9， - 或者 . 的字符这里主机名是 http://google.com ，所以没有非 ASCII 的字符；如果有的话，浏览器会对主机名部分使用 Punycode 编码检查 HSTS 列表浏览器检查自带的「预加载 HSTS（HTTP严格传输安全）」列表，这个列表里包含了那些请求浏览器只使用 HTTPS 进行连接的网站如果网站在这个列表里，浏览器会使用 HTTPS 而不是 HTTP 协议，否则，最初的请求会使用 HTTP 协议发送注意，一个网站哪怕不在 HSTS 列表里，也可以要求浏览器对自己使用 HSTS 政策进行访问。浏览器向网站发出第一个 HTTP 请求之后，网站会返回浏览器一个响应，请求浏览器只使用 HTTPS 发送请求。然而，就是这第一个 HTTP 请求，却可能会使用户受到 downgrade attack 的威胁，这也是为什么现代浏览器都预置了 HSTS 列表。DNS 查询浏览器检查域名是否在缓存当中（要查看 Chrome 当中的缓存， 打开 chrome://net-internals/#dns）。如果缓存中没有，就去调用 gethostbyname 库函数（操作系统不同函数也不同）进行查询。gethostbyname 函数在试图进行DNS解析之前首先检查域名是否在本地 Hosts 里，Hosts 的位置不同的操作系统有所不同如果 gethostbyname 没有这个域名的缓存记录，也没有在 hosts 里找到，它将会向 DNS 服务器发送一条 DNS 查询请求。DNS 服务器是由网络通信栈提供的，通常是本地路由器或者 ISP 的缓存 DNS 服务器。查询本地 DNS 服务器如果 DNS 服务器和我们的主机在同一个子网内，系统会按照下面的 ARP 过程对 DNS 服务器进行 ARP查询如果 DNS 服务器和我们的主机在不同的子网，系统会按照下面的 ARP 过程对默认网关进行查询ARP 过程要想发送 ARP（地址解析协议）广播，我们需要有一个目标 IP 地址，同时还需要知道用于发送 ARP 广播的接口的 MAC 地址。首先查询 ARP 缓存，如果缓存命中，我们返回结果：目标 IP = MAC如果缓存没有命中：查看路由表，看看目标 IP 地址是不是在本地路由表中的某个子网内。是的话，使用跟那个子网相连的接口，否则使用与默认网关相连的接口。查询选择的网络接口的 MAC 地址我们发送一个二层（ OSI 模型 中的数据链路层）ARP 请求：ARP Request:Sender MAC: interface:mac:address:here\nSender IP: interface.ip.goes.here\nTarget MAC: FF:FF:FF:FF:FF:FF (Broadcast)\nTarget IP: target.ip.goes.here\n根据连接主机和路由器的硬件类型不同，可以分为以下几种情况：直连：如果我们和路由器是直接连接的，路由器会返回一个 ARP Reply （见下面）。集线器：如果我们连接到一个集线器，集线器会把 ARP 请求向所有其它端口广播，如果路由器也“连接”在其中，它会返回一个 ARP Reply 。交换机：如果我们连接到了一个交换机，交换机会检查本地 CAM/MAC 表，看看哪个端口有我们要找的那个 MAC 地址，如果没有找到，交换机会向所有其它端口广播这个 ARP 请求。如果交换机的 MAC/CAM 表中有对应的条目，交换机会向有我们想要查询的 MAC 地址的那个端口发送 ARP 请求如果路由器也“连接”在其中，它会返回一个 ARP ReplyARP Reply:Sender MAC: target:mac:address:here\nSender IP: target.ip.goes.here\nTarget MAC: interface:mac:address:here\nTarget IP: interface.ip.goes.here\n现在我们有了 DNS 服务器或者默认网关的 IP 地址，我们可以继续 DNS 请求了：使用 53 端口向 DNS 服务器发送 UDP 请求包，如果响应包太大，会使用 TCP 协议如果本地 /ISP DNS 服务器没有找到结果，它会发送一个递归查询请求，一层一层向高层 DNS 服务器做查询，直到查询到起始授权机构，如果找到会把结果返回使用套接字当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数 socket ，请求一个 TCP 流套接字，对应的参数是 AF_INET/AF_INET6 和 SOCK_STREAM 。这个请求首先被交给传输层，在传输层请求被封装成 TCP segment。目标端口会被加入头部，源端口会在系统内核的动态端口范围内选取（Linux下是 ip_local_port_range）TCP segment 被送往网络层，网络层会在其中再加入一个 IP 头部，里面包含了目标服务器的 IP 地址以及本机的 IP 地址，把它封装成一个TCP packet。这个 TCP packet 接下来会进入链路层，链路层会在封包中加入 frame 头部，里面包含了本地内置网卡的 MAC 地址以及网关（本地路由器）的 MAC 地址。像前面说的一样，如果内核不知道网关的 MAC 地址，它必须进行 ARP 广播来查询其地址。到了现在，TCP 封包已经准备好了，可以使用下面的方式进行传输：以太网WiFi蜂窝数据网络对于大部分家庭网络和小型企业网络来说，封包会从本地计算机出发，经过本地网络，再通过调制解调器把数字信号转换成模拟信号，使其适于在电话线路，有线电视光缆和无线电话线路上传输。在传输线路的另一端，是另外一个调制解调器，它把模拟信号转换回数字信号，交由下一个网络节点处理。节点的目标地址和源地址将在后面讨论。大型企业和比较新的住宅通常使用光纤或直接以太网连接，这种情况下信号一直是数字的，会被直接传到下一个网络节点进行处理。最终封包会到达管理本地子网的路由器。在那里出发，它会继续经过自治区域（autonomous system, 缩写 AS）的边界路由器，其他自治区域，最终到达目标服务器。一路上经过的这些路由器会从IP数据报头部里提取出目标地址，并将封包正确地路由到下一个目的地。IP 数据报头部 time to live (TTL) 域的值每经过一个路由器就减 1，如果封包的 TTL 变为 0，或者路由器由于网络拥堵等原因封包队列满了，那么这个包会被路由器丢弃。上面的发送和接受过程在 TCP 连接期间会发生很多次：客户端选择一个初始序列号 (ISN)，将设置了 SYN 位的封包发送给服务器端，表明自己要建立连接并设置了初始序列号服务器端接收到 SYN 包，如果它可以建立连接：服务器端选择它自己的初始序列号服务器端设置 SYN 位，表明自己选择了一个初始序列号服务器端把（客户端ISN + 1）复制到 ACK 域，并且设置 ACK 位，表明自己接收到了客户端的第一个封包客户端通过发送下面一个封包来确认这次连接：自己的序列号+1接收端 ACK+1设置 ACK 位数据通过下面的方式传输：当一方发送了N个 Bytes 的数据之后，将自己的 SEQ 序列号也增加N另一方确认接收到这个数据包（或者一系列数据包）之后，它发送一个 ACK 包，ACK 的值设置为接收到的数据包的最后一个序列号关闭连接时：要关闭连接的一方发送一个 FIN 包另一方确认这个 FIN 包，并且发送自己的 FIN 包要关闭的一方使用 ACK 包来确认接收到了 FINTLS 握手客户端发送一个 ClientHello 消息到服务器端，消息中同时包含了它的 Transport Layer Security (TLS) 版本，可用的加密算法和压缩算法。服务器端向客户端返回一个 ServerHello 消息，消息中包含了服务器端的 TLS 版本，服务器所选择的加密和压缩算法，以及数字证书认证机构（Certificate Authority，缩写 CA）签发的服务器公开证书，证书中包含了公钥。客户端会使用这个公钥加密接下来的握手过程，直到协商生成一个新的对称密钥客户端根据自己的信任 CA 列表，验证服务器端的证书是否可信。如果认为可信，客户端会生成一串伪随机数，使用服务器的公钥加密它。这串随机数会被用于生成新的对称密钥服务器端使用自己的私钥解密上面提到的随机数，然后使用这串随机数生成自己的对称主密钥客户端发送一个 Finished 消息给服务器端，使用对称密钥加密这次通讯的一个散列值服务器端生成自己的 hash 值，然后解密客户端发送来的信息，检查这两个值是否对应。如果对应，就向客户端发送一个 Finished 消息，也使用协商好的对称密钥加密从现在开始，接下来整个 TLS 会话都使用对称秘钥进行加密，传输应用层（HTTP）内容HTTP 协议如果浏览器是 Google 出品的，它不会使用 HTTP 协议来获取页面信息，而是会与服务器端发送请求，商讨使用 SPDY 协议。如果浏览器使用 HTTP 协议而不支持 SPDY 协议，它会向服务器发送这样的一个请求:GET / HTTP/1.1\nHost: google.com\nConnection: close\n[other headers]\n[other headers] 包含了一系列的由冒号分割开的键值对，它们的格式符合 HTTP 协议标准，它们之间由一个换行符分割开来。（这里我们假设浏览器没有违反 HTTP 协议标准的 bug，同时假设浏览器使用 HTTP/1.1 协议，不然的话头部可能不包含 Host 字段，同时 GET 请求中的版本号会变成 HTTP/1.0 或者 HTTP/0.9 。）HTTP/1.1 定义了「关闭连接」的选项「close」，发送者使用这个选项指示这次连接在响应结束之后会断开。例如：Connection:close不支持持久连接的 HTTP/1.1 应用必须在每条消息中都包含「close」选项。在发送完这些请求和头部之后，浏览器发送一个换行符，表示要发送的内容已经结束了。服务器端返回一个响应码，指示这次请求的状态，响应的形式是这样的:200 OK\n[response headers]\n然后是一个换行，接下来有效载荷 (payload)，也就是 http://www.google.com 的 HTML 内容。服务器下面可能会关闭连接，如果客户端请求保持连接的话，服务器端会保持连接打开，以供之后的请求重用。如果浏览器发送的 HTTP 头部包含了足够多的信息（例如包含了 Etag 头部），以至于服务器可以判断出，浏览器缓存的文件版本自从上次获取之后没有再更改过，服务器可能会返回这样的响应:304 Not Modified\n[response headers]\n这个响应没有有效载荷，浏览器会从自己的缓存中取出想要的内容。在解析完 HTML 之后，浏览器和客户端会重复上面的过程，直到 HTML 页面引入的所有资源（图片，CSS，favicon.ico 等等）全部都获取完毕，区别只是头部的 GET / HTTP/1.1 会变成 GET /$(相对http://www.google.com的URL) HTTP/1.1 。如果 HTML 引入了 http://www.google.com 域名之外的资源，浏览器会回到上面解析域名那一步，按照下面的步骤往下一步一步执行，请求中的 Host 头部会变成另外的域名。HTTP 服务器请求处理HTTPD(HTTP Daemon) 在服务器端处理请求 / 响应。最常见的 HTTPD 有 Linux 上常用的 Apache 和 nginx，以及 Windows 上的 IIS。HTTPD 接收请求服务器把请求拆分为以下几个参数：HTTP 请求方法（GET, POST, HEAD, PUT, DELETE, CONNECT, OPTIONS, 或者 TRACE）。直接在地址栏中输入 URL 这种情况下，使用的是 GET 方法域名：http://google.com请求路径/页面：/ (我们没有请求http://google.com下的指定的页面，因此 / 是默认的路径)服务器验证其上已经配置了 http://google.com 的虚拟主机服务器验证 http://google.com 接受 GET 方法服务器验证该用户可以使用 GET 方法（根据 IP 地址，身份信息等）如果服务器安装了 URL 重写模块（例如 Apache 的 mod_rewrite 和 IIS 的 URL Rewrite），服务器会尝试匹配重写规则，如果匹配上的话，服务器会按照规则重写这个请求服务器根据请求信息获取相应的响应内容，这种情况下由于访问路径是「/」，会访问首页文件（你可以重写这个规则，但是这个是最常用的）。服务器会使用指定的处理程序分析处理这个文件，假如 Google 使用 PHP，服务器会使用 PHP 解析 index 文件，并捕获输出，把 PHP 的输出结果返回给请求者浏览器背后的故事当服务器提供了资源之后（HTML，CSS，JS，图片等），浏览器会执行下面的操作：解析 —— HTML，CSS，JS渲染 —— 构建 DOM 树 -&gt; 渲染 -&gt; 布局 -&gt; 绘制浏览器浏览器的功能是从服务器上取回你想要的资源，然后展示在浏览器窗口当中。资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。资源的位置通过用户提供的 URI (Uniform Resource Identifier) 来确定。浏览器解释和展示 HTML 文件的方法，在 HTML 和 CSS 的标准中有详细介绍。这些标准由 Web 标准组织 W3C (World Wide Web Consortium) 维护。不同浏览器的用户界面大都十分接近，有很多共同的 UI 元素：一个地址栏后退和前进按钮书签选项刷新和停止按钮主页按钮浏览器高层架构组成浏览器的组件有：用户界面 用户界面包含了地址栏，前进后退按钮，书签菜单等等，除了请求页面之外所有你看到的内容都是用户界面的一部分浏览器引擎 浏览器引擎负责让 UI 和渲染引擎协调工作渲染引擎 渲染引擎负责展示请求内容。如果请求的内容是 HTML，渲染引擎会解析 HTML 和 CSS，然后将内容展示在屏幕上网络组件 网络组件负责网络调用，例如 HTTP 请求等，使用一个平台无关接口，下层是针对不同平台的具体实现UI后端 UI 后端用于绘制基本 UI 组件，例如下拉列表框和窗口。UI 后端暴露一个统一的平台无关的接口，下层使用操作系统的 UI 方法实现Javascript 引擎 Javascript 引擎用于解析和执行 Javascript 代码数据存储 数据存储组件是一个持久层。浏览器可能需要在本地存储各种各样的数据，例如 Cookie 等。浏览器也需要支持诸如 localStorage，IndexedDB，WebSQL 和 FileSystem 之类的存储机制HTML 解析浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成 8kB 大小的分块传输。HTML 解析器的主要工作是对 HTML 文档进行解析，生成解析树。解析树是以 DOM 元素以及属性为节点的树。DOM 是文档对象模型 (Document Object Model)的缩写，它是 HTML 文档的对象表示，同时也是 HTML 元素面向外部（如 JavaScript）的接口。树的根部是「Document」对象。整个 DOM 和 HTML 文档几乎是一对一的关系。解析算法HTML 不能使用常见的自顶向下或自底向上方法来进行分析。主要原因有以下几点:语言本身的「宽容」特性HTML 本身可能是残缺的，对于常见的残缺，浏览器需要有传统的容错机制来支持它们解析过程需要反复。对于其他语言来说，源码不会在解析过程中发生变化，但是对于 HTML 来说，动态代码，例如脚本元素中包含的 document.write() 方法会在源码中添加内容，也就是说，解析过程实际上会改变输入的内容由于不能使用常用的解析技术，浏览器创造了专门用于解析 HTML 的解析器。解析算法在 HTML5 标准规范中有详细介绍，算法主要包含了两个阶段：标记化（tokenization）和树的构建。解析结束之后浏览器开始加载网页的外部资源（CSS，图像，Javascript 文件等）。此时浏览器把文档标记为可交互的（interactive），浏览器开始解析处于「推迟（deferred）」模式的脚本，也就是那些需要在文档解析完毕之后再执行的脚本。之后文档的状态会变为「完成（complete）」，浏览器会触发「加载（load）」事件。注意解析 HTML 网页时永远不会出现「无效语法（Invalid Syntax）」错误，浏览器会修复所有错误内容，然后继续解析。CSS 解析根据 CSS词法和句法 分析 CSS 文件和 &lt;style&gt; 标签包含的内容以及 style 属性的值每个 CSS 文件都被解析成一个样式表对象（StyleSheet object），这个对象里包含了带有选择器的 CSS 规则，和对应 CSS 语法的对象CSS 解析器可能是自顶向下的，也可能是使用解析器生成器生成的自底向上的解析器页面渲染通过遍历 DOM 节点树创建一个「Frame 树」或「渲染树」，并计算每个节点的各个 CSS 样式值通过累加子节点的宽度，该节点的水平内边距 (padding)、边框 (border) 和外边距(margin)，自底向上的计算「Frame 树」中每个节点的首选 (preferred) 宽度通过自顶向下的给每个节点的子节点分配可行宽度，计算每个节点的实际宽度通过应用文字折行、累加子节点的高度和此节点的内边距 (padding)、边框 (border) 和外边距 (margin)，自底向上的计算每个节点的高度使用上面的计算结果构建每个节点的坐标当存在元素使用 floated，位置有 absolutely 或 relatively 属性的时候，会有更多复杂的计算，详见 http://dev.w3.org/csswg/css2/ 和 http://www.w3.org/Style/CSS/current-work创建 layer (层) 来表示页面中的哪些部分可以成组的被绘制，而不用被重新栅格化处理。每个帧对象都被分配给一个层页面上的每个层都被分配了纹理每个层的帧对象都会被遍历，计算机执行绘图命令绘制各个层，此过程可能由 CPU 执行栅格化处理，或者直接通过 D2D / SkiaGL 在 GPU 上绘制上面所有步骤都可能利用到最近一次页面渲染时计算出来的各个值，这样可以减少不少计算量计算出各个层的最终位置，一组命令由 Direct3D/OpenGL 发出，GPU 命令缓冲区清空，命令传至 GPU 并异步渲染，帧被送到 Window Server。GPU 渲染在渲染过程中，图形处理层可能使用通用用途的 CPU，也可能使用图形处理器 GPU当使用 GPU 用于图形渲染时，图形驱动软件会把任务分成多个部分，这样可以充分利用 GPU 强大的并行计算能力，用于在渲染过程中进行大量的浮点计算。Window Server后期渲染与用户引发的处理渲染结束后，浏览器根据某些时间机制运行 JavaScript 代码（比如 Google Doodle 动画）或与用户交互（在搜索栏输入关键字获得搜索建议）。类似 Flash 和 Java 的插件也会运行，尽管 Google 主页里没有。这些脚本可以触发网络请求，也可能改变网页的内容和布局，产生又一轮渲染与绘制。', 1, 0, 0, 7, 1, 1),
(31, 'nodejs session 原理及实战', '方老司', '2017-11-08 12:30:48', '2017-11-04 15:28:14', '<p><img data-src="/img/bVTC4m?w=852&amp;h=276" src="https://segmentfault.com/img/bVTC4m?w=852&amp;h=276"></p><h2 id="articleHeader0">一 Cookie</h2><p>因为HTTP协议是没有状态的，但很多情况下是需要一些信息的，比如在用户登陆后、再次访问网站时，没法判断用户是否登陆过。于是就有了cookies，用于在浏览器端保存用户数据，它有如下特点<br>1 是在客户端浏览器端才有的<br>2 用于记录信息，大小最大为4K字节<br>3 如果使用了cookies，那么任何对该域名的访问都会带上cookies</p><p>目前新型网站更多的采用浏览器缓存，cookie会存在一些问题，比如你每次往服务器提交请求时，都会带上cookie，无论是你访问的是不是静态图片。</p><p>cookie例子：<br><img data-src="/img/bVTC5S?w=365&amp;h=363" src="https://segmentfault.com/img/bVTC5S?w=365&amp;h=363"></p><h2 id="articleHeader1">二 Session</h2><p>session类似服务器端的cookie，保存于服务器端，类似于服务器缓存。用户登陆了总需要验证吧，那么就在session中验证即可，session和cookie是一一对应关系。</p><p>session的创建顺序</p><ol><li>生成全局唯一标识符（sessionid）；</li><li>开辟数据存储空间。一般会在内存中创建相应的数据结构，但这种情况下，系统一旦掉电，所有的会话数据就会丢失，如果是电子商务网站，这种事故会造成严重的后果。不过也可以写到文件里甚至存储在数据库中，这样虽然会增加I/O开销，但session可以实现某种程度的持久化，而且更有利于session的共享；</li><li>将session的全局唯一标示符发送给客户端。<br>问题的关键就在服务端如何发送这个session的唯一标识上。联系到HTTP协议，数据无非可以放到请求行、头域或Body里，基于此，一般来说会有两种常用的方式：cookie和URL重写。</li></ol><h2 id="articleHeader2">三 Set-Cookie</h2><p>Cookie是如何被设置的呢？是被服务器返回的请求设置的。</p><p><img data-src="/img/bVTC7y?w=442&amp;h=387" src="https://segmentfault.com/img/bVTC7y?w=442&amp;h=387"></p><p>服务器会返回一个set-cookie的消息，通知浏览器要设置cookie了，于是浏览器会根据set-cookie里的字段来设置信息了，比如上图的信息就会设置session=r@rdegges.com</p><h2 id="articleHeader3">四 实战</h2><p>我们以client-session（express-session基本完全一样）为例，为项目配置session<br>1 安装模块</p><pre><code>var session&nbsp;= require(''client-sessions'');</code></pre><p>2 配置session</p><pre><code>app.use(session({\n  cookieName: ''session'',\n  secret: ''random_string_goes_here'',\n  duration: 30 * 60 * 1000,\n  activeDuration: 5 * 60 * 1000,\n}));\n</code></pre><p>1）secret：一个随机字符串，因为客户端的数据都是不安全的，所以需要进行加密<br>2) duration：session的过期时间，过期了就必须重新设置<br>3) activeDuration: 激活时间，比如设置为30分钟，那么只要30分钟内用户有服务器的交互，那么就会被重新激活。</p><h2 id="articleHeader4">五 在Session中保存用户信息</h2><pre><code>app.post(''/login'', function(req, res) {\n  User.findOne({ email: req.body.email }, function(err, user) {\n    if (!user) {\n      res.render(''login.jade'', { error: ''Invalid email or password.'' });\n    } else {\n      if (req.body.password === user.password) {\n        \n        // sets a cookie with the user''s info\n        req.session.user = user;\n        // 这里貌似有误，只是set了session，返回这个sessionid，但但数据并不会set到这个cookie里头\n        \n        res.redirect(''/dashboard'');\n      } else {\n        res.render(''login.jade'', { error: ''Invalid email or password.'' });\n      }\n    }\n  });\n});\n</code></pre><h2 id="articleHeader5">六 Session层中间件</h2><p>我们当然不希望每个请求都加上这一段，所以我们使用express来做全局配置</p><pre><code>app.use(function(req, res, next) {\n  if (req.session &amp;&amp; req.session.user) {\n    User.findOne({ email: req.session.user.email }, function(err, user) {\n      if (user) {\n        req.user = user;\n        delete req.user.password; // delete the password from the session\n        req.session.user = user;  //refresh the session value\n        res.locals.user = user;\n      }\n      // finishing processing the middleware and run the route\n      next();\n    });\n  } else {\n    next();\n  }\n});\n</code></pre><p>如果用户逻辑在没有登陆时必须登陆，那我们可以继续加一个路由</p><pre><code>function requireLogin (req, res, next) {\n  if (!req.user) {\n    res.redirect(''/login'');\n  } else {\n    next();\n  }\n};\n\napp.get(''/dashboard'', requireLogin, function(req, res) {\n  res.render(''dashboard.jade'');\n});\n</code></pre><h2 id="articleHeader6">七 安全性</h2><p>1 我们可以在登出时重置session</p><pre><code>app.get(''/logout'', function(req, res) {\n  req.session.reset();\n  res.redirect(''/'');\n});</code></pre><p>还可以加一些安全性<br>httpOnly：用来保证cookie只能通过http访问，而不能用js来读取<br>secure：强制使用https<br>ephemeral：关闭浏览器时同时关闭cookie</p><h2 id="articleHeader7">八 总结</h2><p>Cookie和session由于实现手段不同，因此也各有优缺点和各自的应用场景：</p><ol><li>应用场景<br>Cookie的典型应用场景是Remember Me服务，即用户的账户信息通过cookie的形式保存在客户端，当用户再次请求匹配的URL的时候，账户信息会被传送到服务端，交由相应的程序完成自动登录等功能。当然也可以保存一些客户端信息，比如页面布局以及搜索历史等等。</li></ol><p>Session的典型应用场景是用户登录某网站之后，将其登录信息放入session，在以后的每次请求中查询相应的登录信息以确保该用户合法。当然还是有购物车等等经典场景；</p><ol><li>安全性<br>cookie将信息保存在客户端，如果不进行加密的话，无疑会暴露一些隐私信息，安全性很差，一般情况下敏感信息是经过加密后存储在cookie中，但很容易就会被窃取。而session只会将信息存储在服务端，如果存储在文件或数据库中，也有被窃取的可能，只是可能性比cookie小了太多。</li></ol><p>Session安全性方面比较突出的是存在会话劫持的问题，这是一种安全威胁，这在下文会进行更详细的说明。总体来讲，session的安全性要高于cookie；</p><ol><li>性能<br>Cookie存储在客户端，消耗的是客户端的I/O和内存，而session存储在服务端，消耗的是服务端的资源。但是session对服务器造成的压力比较集中，而cookie很好地分散了资源消耗，就这点来说，cookie是要优于session的；</li><li>时效性<br>Cookie可以通过设置有效期使其较长时间内存在于客户端，而session一般只有比较短的有效期（用户主动销毁session或关闭浏览器后引发超时）；</li><li>其他<br>Cookie的处理在开发中没有session方便。而且cookie在客户端是有数量和大小的限制的，而session的大小却只以硬件为限制，能存储的数据无疑大了太多。</li></ol><p><br></p>', '一 Cookie因为HTTP协议是没有状态的，但很多情况下是需要一些信息的，比如在用户登陆后、再次访问网站时，没法判断用户是否登陆过。于是就有了cookies，用于在浏览器端保存用户数据，它有如下特点1 是在客户端浏览器端才有的2 用于记录信息，大小最大为4K字节3 如果使用了cookies，那么任何对该域名的访问都会带上cookies目前新型网站更多的采用浏览器缓存，cookie会存在一些问题，比如你每次往服务器提交请求时，都会带上cookie，无论是你访问的是不是静态图片。cookie例子：二 Sessionsession类似服务器端的cookie，保存于服务器端，类似于服务器缓存。用户登陆了总需要验证吧，那么就在session中验证即可，session和cookie是一一对应关系。session的创建顺序生成全局唯一标识符（sessionid）；开辟数据存储空间。一般会在内存中创建相应的数据结构，但这种情况下，系统一旦掉电，所有的会话数据就会丢失，如果是电子商务网站，这种事故会造成严重的后果。不过也可以写到文件里甚至存储在数据库中，这样虽然会增加I/O开销，但session可以实现某种程度的持久化，而且更有利于session的共享；将session的全局唯一标示符发送给客户端。问题的关键就在服务端如何发送这个session的唯一标识上。联系到HTTP协议，数据无非可以放到请求行、头域或Body里，基于此，一般来说会有两种常用的方式：cookie和URL重写。三 Set-CookieCookie是如何被设置的呢？是被服务器返回的请求设置的。服务器会返回一个set-cookie的消息，通知浏览器要设置cookie了，于是浏览器会根据set-cookie里的字段来设置信息了，比如上图的信息就会设置session=r@rdegges.com四 实战我们以client-session（express-session基本完全一样）为例，为项目配置session1 安装模块var session = require(''client-sessions'');2 配置sessionapp.use(session({\n  cookieName: ''session'',\n  secret: ''random_string_goes_here'',\n  duration: 30 * 60 * 1000,\n  activeDuration: 5 * 60 * 1000,\n}));\n1）secret：一个随机字符串，因为客户端的数据都是不安全的，所以需要进行加密2) duration：session的过期时间，过期了就必须重新设置3) activeDuration: 激活时间，比如设置为30分钟，那么只要30分钟内用户有服务器的交互，那么就会被重新激活。五 在Session中保存用户信息app.post(''/login'', function(req, res) {\n  User.findOne({ email: req.body.email }, function(err, user) {\n    if (!user) {\n      res.render(''login.jade'', { error: ''Invalid email or password.'' });\n    } else {\n      if (req.body.password === user.password) {\n        \n        // sets a cookie with the user''s info\n        req.session.user = user;\n        // 这里貌似有误，只是set了session，返回这个sessionid，但但数据并不会set到这个cookie里头\n        \n        res.redirect(''/dashboard'');\n      } else {\n        res.render(''login.jade'', { error: ''Invalid email or password.'' });\n      }\n    }\n  });\n});\n六 Session层中间件我们当然不希望每个请求都加上这一段，所以我们使用express来做全局配置app.use(function(req, res, next) {\n  if (req.session &amp;&amp; req.session.user) {\n    User.findOne({ email: req.session.user.email }, function(err, user) {\n      if (user) {\n        req.user = user;\n        delete req.user.password; // delete the password from the session\n        req.session.user = user;  //refresh the session value\n        res.locals.user = user;\n      }\n      // finishing processing the middleware and run the route\n      next();\n    });\n  } else {\n    next();\n  }\n});\n如果用户逻辑在没有登陆时必须登陆，那我们可以继续加一个路由function requireLogin (req, res, next) {\n  if (!req.user) {\n    res.redirect(''/login'');\n  } else {\n    next();\n  }\n};\n\napp.get(''/dashboard'', requireLogin, function(req, res) {\n  res.render(''dashboard.jade'');\n});\n七 安全性1 我们可以在登出时重置sessionapp.get(''/logout'', function(req, res) {\n  req.session.reset();\n  res.redirect(''/'');\n});还可以加一些安全性httpOnly：用来保证cookie只能通过http访问，而不能用js来读取secure：强制使用httpsephemeral：关闭浏览器时同时关闭cookie八 总结Cookie和session由于实现手段不同，因此也各有优缺点和各自的应用场景：应用场景Cookie的典型应用场景是Remember Me服务，即用户的账户信息通过cookie的形式保存在客户端，当用户再次请求匹配的URL的时候，账户信息会被传送到服务端，交由相应的程序完成自动登录等功能。当然也可以保存一些客户端信息，比如页面布局以及搜索历史等等。Session的典型应用场景是用户登录某网站之后，将其登录信息放入session，在以后的每次请求中查询相应的登录信息以确保该用户合法。当然还是有购物车等等经典场景；安全性cookie将信息保存在客户端，如果不进行加密的话，无疑会暴露一些隐私信息，安全性很差，一般情况下敏感信息是经过加密后存储在cookie中，但很容易就会被窃取。而session只会将信息存储在服务端，如果存储在文件或数据库中，也有被窃取的可能，只是可能性比cookie小了太多。Session安全性方面比较突出的是存在会话劫持的问题，这是一种安全威胁，这在下文会进行更详细的说明。总体来讲，session的安全性要高于cookie；性能Cookie存储在客户端，消耗的是客户端的I/O和内存，而session存储在服务端，消耗的是服务端的资源。但是session对服务器造成的压力比较集中，而cookie很好地分散了资源消耗，就这点来说，cookie是要优于session的；时效性Cookie可以通过设置有效期使其较长时间内存在于客户端，而session一般只有比较短的有效期（用户主动销毁session或关闭浏览器后引发超时）；其他Cookie的处理在开发中没有session方便。而且cookie在客户端是有数量和大小的限制的，而session的大小却只以硬件为限制，能存储的数据无疑大了太多。', 1, 0, 0, 7, 1, 1),
(32, 'Javascript的模块管理 CMD AMD ES7等', '方老司', '2017-11-08 12:30:45', '2017-11-04 15:29:30', '<h2 id="articleHeader0">一 Commonjs</h2><p>一开始js是垃圾，但随着时代的发展、业务的进步，js变得越来越重要，但js涉及之初就是用来打杂的，有缺陷如下：</p><ol><li>JavaScript has no module system. To compose JavaScript scripts, they must be either managed in HTML, concatenated, injected, or manually fetched and evaluated. There is no native facility for scope isolation or dependency management.</li><li>JavaScript has no standard library. It has a browser API, dates, and math, but no file system API, much less an IO stream API or primordial types for binary data.</li><li>JavaScript has no standard interfaces for things like Web servers or databases.</li><li>JavaScript has no package management system that manages dependencies and automatically installs them, except JSAN (not to be confused with JSON), which falls short for scope isolation.</li></ol><p>简单翻译下：</p><ol><li>没有模块系统</li><li>没有标准库、没有文件、没有IO系统</li><li>没有标准接口，用来做服务器、或者数据库</li><li>没有依赖包管理系统。</li></ol><p>所以mozila的工程师希望来解决这个问题</p><p>“What I’m describing here is not a technical problem. It’s a matter of people getting together and making a decision to step forward and start building up something bigger and cooler together.”</p><p>这并不是一个技术问题，而是为了便于更多人合作...</p><p>所以就有了commonjs，定义了这些概念，而nodejs实现了这个标准。<br>CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)}<br>比如这个样子:</p><pre><code>// foo.js\nmodule.exports = function(x) {\n  console.log(x);\n};\n\n// main.js\nvar foo = require("./foo");\nfoo("Hi");\n</code></pre><p>看似完美的解决了模块问题，但在浏览器模式下是不行的，假设我们有如下这段代码</p><pre><code>var math = require(''math'');\nmath.add(2, 3);</code></pre><p>问题1：math.add会被阻塞掉，必须在require完成之后再执行<br>问题2：即使能够异步加载，但你如何能够知道什么时候加载完毕，什么时候能够执行完么？</p><h2 id="articleHeader1">二 AMD</h2><p>(Asynchronous Module Definition) 异步模块加载<br>这里不得不说到我们的requirejs，它有两个参数 <br>　</p><pre><code>require([module], callback);\n</code></pre><p>第一个表示依赖的模块，第二个就是具体的回掉了，比如上上述的代码</p><pre><code>require([''math''], function (math) {\n　　　　math.add(2, 3);\n　　});</code></pre><h2 id="articleHeader2">三 ES6</h2><p>ES6中的模块最大的特点就是静态，即在编译时就确定依赖关系，ES6中会自然采用严格模式：</p><ol><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用with语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀0表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量delete prop，会报错，只能删除属性delete global[prop]</li><li>eval不会在它的外层作用域引入变量</li><li>eval和arguments不能被重新赋值</li><li>arguments不会自动反映函数参数的变化</li><li>不能使用arguments.callee</li><li>不能使用arguments.caller</li><li>禁止this指向全局对象</li><li>不能使用fn.caller和fn.arguments获取函数调用的堆栈</li><li>增加了保留字（比如protected、static和interface）</li></ol><p>参考：<a href="http://www.cnblogs.com/chenguangliang/p/5856701.html" target="_blank">http://www.cnblogs.com/chengu...</a></p>', '一 Commonjs一开始js是垃圾，但随着时代的发展、业务的进步，js变得越来越重要，但js涉及之初就是用来打杂的，有缺陷如下：JavaScript has no module system. To compose JavaScript scripts, they must be either managed in HTML, concatenated, injected, or manually fetched and evaluated. There is no native facility for scope isolation or dependency management.JavaScript has no standard library. It has a browser API, dates, and math, but no file system API, much less an IO stream API or primordial types for binary data.JavaScript has no standard interfaces for things like Web servers or databases.JavaScript has no package management system that manages dependencies and automatically installs them, except JSAN (not to be confused with JSON), which falls short for scope isolation.简单翻译下：没有模块系统没有标准库、没有文件、没有IO系统没有标准接口，用来做服务器、或者数据库没有依赖包管理系统。所以mozila的工程师希望来解决这个问题“What I’m describing here is not a technical problem. It’s a matter of people getting together and making a decision to step forward and start building up something bigger and cooler together.”这并不是一个技术问题，而是为了便于更多人合作...所以就有了commonjs，定义了这些概念，而nodejs实现了这个标准。CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)}比如这个样子:// foo.js\nmodule.exports = function(x) {\n  console.log(x);\n};\n\n// main.js\nvar foo = require("./foo");\nfoo("Hi");\n看似完美的解决了模块问题，但在浏览器模式下是不行的，假设我们有如下这段代码var math = require(''math'');\nmath.add(2, 3);问题1：math.add会被阻塞掉，必须在require完成之后再执行问题2：即使能够异步加载，但你如何能够知道什么时候加载完毕，什么时候能够执行完么？二 AMD(Asynchronous Module Definition) 异步模块加载这里不得不说到我们的requirejs，它有两个参数 　require([module], callback);\n第一个表示依赖的模块，第二个就是具体的回掉了，比如上上述的代码require([''math''], function (math) {\n　　　　math.add(2, 3);\n　　});三 ES6ES6中的模块最大的特点就是静态，即在编译时就确定依赖关系，ES6中会自然采用严格模式：变量必须声明后再使用函数的参数不能有同名属性，否则报错不能使用with语句不能对只读属性赋值，否则报错不能使用前缀0表示八进制数，否则报错不能删除不可删除的属性，否则报错不能删除变量delete prop，会报错，只能删除属性delete global[prop]eval不会在它的外层作用域引入变量eval和arguments不能被重新赋值arguments不会自动反映函数参数的变化不能使用arguments.callee不能使用arguments.caller禁止this指向全局对象不能使用fn.caller和fn.arguments获取函数调用的堆栈增加了保留字（比如protected、static和interface）参考：http://www.cnblogs.com/chengu...', 1, 0, 0, 6, 1, 1),
(351, '关于我', '宫关', '2017-10-13 05:49:41', '2017-10-13 08:09:09', '&nbsp; &nbsp; <b>个人资料</b>：男，90后，IT男，狮子座，爱吃肉，却很瘦。<div><br><div>&nbsp; &nbsp; <b>爱</b>&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<b>好：</b>编程，游戏，旅游，看书一系列大杂烩。</div><div><br></div><div>&nbsp; &nbsp; <b>个人简介：</b><br><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 理科生中的文科生，文科生中的理科生。高考仅以200多分之差与清华北大失之交臂，甚是可惜。若上天眷恋机会重来，可能此时的我正在北大的未名湖上泛舟。然而没有如果，常叹过去也非君子本色。<br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 为了迎接新生活，在下一改往日害羞内向，要在大学的磨炼厂中蜕变成无视场合都能谈笑自如，挥斥方遒的人。好吧，我失败了。<br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 大学四年，游戏人生、思考生活、探讨人生哲理。自诩人间逍遥客，可惜心中藏泰山。心怀天下、振新中华，社会主义接班人的神秘身份再也隐藏不住。<br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 自小对计算机的热爱，大学数年对计算机的熏陶，终让我走上了IT这条不归路。面对“bug”这位程序员亘古不变的宿敌，我毫不退缩。前有鲁迅先生弃医从文、拯救苍生，今有小生仗“键“天涯，与代码作斗争，携一架键盘，开天辟地，成为拯救世界的另类“键盘侠”！<br></p><p><br></p><p><br></p><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<br></p></div></div>', '    个人资料：男，90后，IT男，狮子座，爱吃肉，却很瘦。    爱      好：编程，游戏，旅游，看书一系列大杂烩。    个人简介：                    理科生中的文科生，文科生中的理科生。高考仅以200多分之差与清华北大失之交臂，甚是可惜。若上天眷恋机会重来，可能此时的我正在北大的未名湖上泛舟。然而没有如果，常叹过去也非君子本色。                    为了迎接新生活，在下一改往日害羞内向，要在大学的磨炼厂中蜕变成无视场合都能谈笑自如，挥斥方遒的人。好吧，我失败了。                    大学四年，游戏人生、思考生活、探讨人生哲理。自诩人间逍遥客，可惜心中藏泰山。心怀天下、振新中华，社会主义接班人的神秘身份再也隐藏不住。                    自小对计算机的热爱，大学数年对计算机的熏陶，终让我走上了IT这条不归路。面对“bug”这位程序员亘古不变的宿敌，我毫不退缩。前有鲁迅先生弃医从文、拯救苍生，今有小生仗“键“天涯，与代码作斗争，携一架键盘，开天辟地，成为拯救世界的另类“键盘侠”！                  ', 3, 1, 0, 1, 1, 1),
(355, '草稿1', '宫关', '2017-11-15 08:15:52', '2017-11-15 08:15:52', '1', '1', 1, 1, 0, 1, 1, 0),
(356, '草稿2', '宫关', '2017-11-15 08:16:05', '2017-11-15 08:16:05', '2', '2', 1, 1, 0, 1, 1, 0),
(357, '草稿3', '宫关', '2017-11-15 08:16:12', '2017-11-15 08:16:12', '3', '3', 1, 1, 0, 1, 1, 0),
(358, '草稿4', '宫关', '2017-11-15 08:16:18', '2017-11-15 08:16:18', '', '', 1, 1, 0, 1, 1, 0),
(359, '草稿5', '宫关', '2017-11-15 08:16:24', '2017-11-15 08:16:24', '', '', 1, 1, 0, 1, 1, 0),
(360, '草稿6', '宫关', '2017-11-15 08:16:30', '2017-11-15 08:16:30', '', '', 1, 1, 0, 1, 1, 0),
(361, '草稿7', '宫关', '2017-11-15 08:16:35', '2017-11-15 08:16:35', '', '', 1, 1, 0, 1, 1, 0);

-- --------------------------------------------------------

--
-- 表的结构 `blog_article_category`
--

CREATE TABLE `blog_article_category` (
  `category_id` int(11) NOT NULL,
  `category_name` varchar(4) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- 转存表中的数据 `blog_article_category`
--

INSERT INTO `blog_article_category` VALUES
(0, '转载'),
(1, '原创');

-- --------------------------------------------------------

--
-- 表的结构 `blog_article_family`
--

CREATE TABLE `blog_article_family` (
  `family_id` int(11) NOT NULL,
  `family_name` varchar(4) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- 转存表中的数据 `blog_article_family`
--

INSERT INTO `blog_article_family` VALUES
(1, '前端技术'),
(2, '生活杂文'),
(3, '随笔');

-- --------------------------------------------------------

--
-- 表的结构 `blog_comment`
--

CREATE TABLE `blog_comment` (
  `comment_id` int(11) NOT NULL,
  `comment_person_name` varchar(8) DEFAULT NULL,
  `comment_person_web` varchar(256) DEFAULT NULL,
  `comment_person_mail` varchar(32) DEFAULT NULL,
  `comment_content` varchar(1024) DEFAULT NULL,
  `comment_date` timestamp NULL DEFAULT CURRENT_TIMESTAMP,
  `comment_article_id` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- 转存表中的数据 `blog_comment`
--

INSERT INTO `blog_comment` VALUES
(1, '张三丰', 'www.sanfengZhang.com', 'sanfeng@163.com', '这本秘籍真是让老夫大开眼界，老夫活了两百多年还是这么孤陋寡闻，真是羞煞老夫也！', '2017-11-09 12:53:34', 1),
(2, '张无忌', 'www.zhangwuji.com', 'wujizhang@gamil.com', '我纵横江湖数余载，从未见过如此功夫，这招式凌厉程度，怕是远在我乾坤大挪移之上了！', '2017-11-09 12:56:30', 1),
(3, '杨过', 'www.yangguo.com', 'yangguo@163.com', '百年难得一见的好文，拿回去给姑姑瞧瞧', '2017-11-10 03:59:17', 1),
(4, '郭襄', '', 'guoxiang@qq.com', '大哥哥说是好的东西，那就一定是好的东西，我也带回去给爹瞧瞧', '2017-11-10 04:12:14', 1);

-- --------------------------------------------------------

--
-- 表的结构 `blog_friendship_link`
--

CREATE TABLE `blog_friendship_link` (
  `link_id` int(11) NOT NULL,
  `link_name` varchar(32) DEFAULT NULL,
  `link_url` varchar(512) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- --------------------------------------------------------

--
-- 表的结构 `blog_reply`
--

CREATE TABLE `blog_reply` (
  `reply_id` int(11) NOT NULL,
  `reply_comment_id` int(11) DEFAULT NULL,
  `reply_person_name` varchar(32) DEFAULT NULL,
  `reply_mail` varchar(128) DEFAULT NULL,
  `reply_web` varchar(256) DEFAULT NULL,
  `reply_content` varchar(2048) DEFAULT NULL,
  `reply_to` varchar(32) DEFAULT NULL,
  `reply_date` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- 转存表中的数据 `blog_reply`
--

INSERT INTO `blog_reply` VALUES
(1, 1, '张无忌', 'wujizhang@163.com', 'www.zhangwuji.com', '师公所言极是', '张三丰', '2017-11-10 03:04:20'),
(2, 2, '张三丰', 'sanfeng@163.com', 'www.zhangsanfeng.com', '不愧是我的好徒孙，眼光独到！', '', '2017-11-10 03:18:42'),
(3, 4, '杨过', 'yangguo@163.com', 'www.yangguo.com', '小姑娘说的对！', '', '2017-11-10 04:15:07'),
(4, 4, '杨过', 'yangguo@163.com', 'www.yangguo.com', '小姑娘有眼光', '', '2017-11-10 04:15:21'),
(5, 3, '小龙女', 'xiaolongnv@163.com', 'www.xiaolongnv.com', '过儿，不用了，姑姑这就来了', '', '2017-11-10 06:25:02'),
(6, 3, '张无忌', 'zhangwuji@163.com', 'www.zhangwuji.com', '师公谬赞了！', '张三丰', '2017-11-10 06:26:01'),
(7, 3, '张三丰', 'sanfeng@163.com', 'www.zhangsanfeng.com', '傻徒儿，你回错地方了', '张无忌', '2017-11-10 06:32:22'),
(8, 2, '张无忌', 'zhangwuji@163.com', 'www.zhangwuji.com', '刚出去跟白眉鹰王喝了两杯，有点晕乎，让师公见笑了！', '张三丰', '2017-11-10 06:33:23'),
(9, 1, '张三丰', 'sanfeng@163.com', 'zhangsanfeng.com', '好徒孙，可别恭维我了！', '张无忌', '2017-11-10 06:39:06'),
(10, 1, '张无忌', 'zhangwuji@163.com', 'www.zhangwuji.com', '师公，我这怎么是恭维呢？徒孙我可都是实话实说！', '张三丰', '2017-11-10 07:25:03'),
(11, 2, '张三丰', 'sanfeng@163.com', 'www.zhangsanfeng.com', '你这孩子，喝酒怎么不叫上我呢？', '张无忌', '2017-11-10 07:27:15'),
(13, 3, '张无忌', 'zhangwuji@163.com', 'www.zhangwuji.com', '额。。。。', '张三丰', '2017-11-10 08:19:40');

-- --------------------------------------------------------

--
-- 表的结构 `blog_visit`
--

CREATE TABLE `blog_visit` (
  `visit_total_count` int(11) DEFAULT NULL,
  `visit_six_ago_count` int(11) DEFAULT NULL,
  `visit_five_ago_count` int(11) DEFAULT NULL,
  `visit_four_ago_count` int(11) DEFAULT NULL,
  `visit_three_ago_count` int(11) DEFAULT NULL,
  `visit_two_ago_count` int(11) DEFAULT NULL,
  `visit_one_ago_count` int(11) DEFAULT NULL,
  `visit_today_count` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Indexes for dumped tables
--

--
-- Indexes for table `blog_administrator`
--
ALTER TABLE `blog_administrator`
  ADD PRIMARY KEY (`admin_id`);

--
-- Indexes for table `blog_article`
--
ALTER TABLE `blog_article`
  ADD PRIMARY KEY (`article_id`);

--
-- Indexes for table `blog_article_category`
--
ALTER TABLE `blog_article_category`
  ADD PRIMARY KEY (`category_id`);

--
-- Indexes for table `blog_article_family`
--
ALTER TABLE `blog_article_family`
  ADD PRIMARY KEY (`family_id`);

--
-- Indexes for table `blog_comment`
--
ALTER TABLE `blog_comment`
  ADD PRIMARY KEY (`comment_id`);

--
-- Indexes for table `blog_friendship_link`
--
ALTER TABLE `blog_friendship_link`
  ADD PRIMARY KEY (`link_id`);

--
-- Indexes for table `blog_reply`
--
ALTER TABLE `blog_reply`
  ADD PRIMARY KEY (`reply_id`);

--
-- 在导出的表使用AUTO_INCREMENT
--

--
-- 使用表AUTO_INCREMENT `blog_administrator`
--
ALTER TABLE `blog_administrator`
  MODIFY `admin_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=2;
--
-- 使用表AUTO_INCREMENT `blog_article`
--
ALTER TABLE `blog_article`
  MODIFY `article_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=363;
--
-- 使用表AUTO_INCREMENT `blog_article_category`
--
ALTER TABLE `blog_article_category`
  MODIFY `category_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=2;
--
-- 使用表AUTO_INCREMENT `blog_article_family`
--
ALTER TABLE `blog_article_family`
  MODIFY `family_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=4;
--
-- 使用表AUTO_INCREMENT `blog_comment`
--
ALTER TABLE `blog_comment`
  MODIFY `comment_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=5;
--
-- 使用表AUTO_INCREMENT `blog_friendship_link`
--
ALTER TABLE `blog_friendship_link`
  MODIFY `link_id` int(11) NOT NULL AUTO_INCREMENT;
--
-- 使用表AUTO_INCREMENT `blog_reply`
--
ALTER TABLE `blog_reply`
  MODIFY `reply_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=14;